/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can read the License at http://opensource.org/licenses/CDDL-1.0
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL Header Notice in
 * each file and include the License file (licence.txt). If applicable,
 * add the following below this CDDL Header, with the fields enclosed
 * by brackets [] replaced by your own identifying information:
 * "Portions Copyright [year] [name of copyright owner]"
 *
 * The Original Software is AtmoSwing. The Initial Developer of the
 * Original Software is Pascal Horton of the University of Lausanne.
 * All Rights Reserved.
 *
 */

/*
 * Portions Copyright 2008-2013 University of Lausanne.
 */

#include "asFileNetcdf.h"

#include <stdint.h> // To get  int32_t and int64_t

asFileNetcdf::asFileNetcdf(const wxString &FileName, const ListFileMode &FileMode)
:
asFile(FileName, FileMode)
{
    m_fileId = 0;
    m_status = 0;
    m_struct.NDims = 0;
    m_struct.NUDims = 0;
    m_struct.NVars = 0;
    m_struct.NAtts = 0;
    m_struct.UDimId = 0;
    m_struct.Format = Classic;
    m_defineMode = false;
}

asFileNetcdf::~asFileNetcdf()
{
    // If file opened
    if (m_fileId!=0)
    {
        Close();
    }
}

bool asFileNetcdf::Open()
{
    if (!Find()) return false;

    wxString datetime, generator;

    if (m_fileMode!=ReadOnly)
    {
        datetime = asTime::GetStringTime(asTime::NowTimeStruct(asLOCAL), DDMMYYYYhhmmss);
        generator = _("Generated by AtmoSwing");
    }

    switch (m_fileMode)
    {
        case (ReadOnly):
        {
            m_defineMode = false;
            m_status = nc_open(m_fileName.GetFullPath().mb_str(wxConvUTF8), NC_NOWRITE, &m_fileId);
            if(m_status) HandleErrorNetcdf();
            m_opened = true;
            if(!ParseStruct())
            {
                asLogError(_("Failed parsing the file structure."));
                ClearStruct();
                return false;
            }
            break;
        }
        case (Write):
        {
            m_defineMode = true;
            m_status = nc_create(m_fileName.GetFullPath().mb_str(wxConvUTF8), NC_NETCDF4|NC_WRITE, &m_fileId);
            if(m_status) HandleErrorNetcdf();
            m_opened = true;
            if(!ParseStruct())
            {
                asLogError(_("Failed parsing the file structure."));
                ClearStruct();
                return false;
            }
            PutAtt("edition_date", datetime);
            break;
        }
        case (Replace):
        {
            m_defineMode = true;
            m_status = nc_create (m_fileName.GetFullPath().mb_str(wxConvUTF8), NC_NETCDF4|NC_CLOBBER, &m_fileId);
            if(m_status) HandleErrorNetcdf();
            m_opened = true;
            PutAtt("creation_date", datetime);
            PutAtt("edition_date", datetime);
            PutAtt("origin", generator);
            break;
        }
        case (New):
        {
            m_defineMode = true;
            m_status = nc_create (m_fileName.GetFullPath().mb_str(wxConvUTF8), NC_NETCDF4|NC_NOCLOBBER, &m_fileId);
            if(m_status) HandleErrorNetcdf();
            m_opened = true;
            PutAtt("creation_date", datetime);
            PutAtt("edition_date", datetime);
            PutAtt("origin", generator);
            break;
        }
        default:
        {
            asThrowException(_("No valid NetCdf FileMode has been selected"));
        }
    }

    m_opened = true;

    return true;
}

bool asFileNetcdf::Close()
{
    // If not already closed
    if (m_fileId!=0)
    {
        CheckDefModeClosed(); // Check that the file is not in define mode
        ClearStruct();
        m_status = nc_close(m_fileId);
        if (m_status) HandleErrorNetcdf();
        m_fileId = 0;
    }

    return true;
}

void asFileNetcdf::HandleErrorNetcdf()
{
    if (m_status != NC_NOERR)
    {
        std::string tmpmessage = nc_strerror(m_status);
        wxString wxtmpmessage(tmpmessage.c_str(), wxConvUTF8);
        wxString errorMessage = wxString::Format(_("NetCDF error in file %s: %s"), m_fileName.GetName(), wxtmpmessage);
        asThrowException(errorMessage);
    }
}

void asFileNetcdf::DefDim(const wxString &DimName, const size_t &DimSize)
{
    wxASSERT(m_opened);

    int DimId;

    // Check that the file is in define mode
    CheckDefModeOpen();

    if (DimSize==0)
    {
        m_status = nc_def_dim(m_fileId, DimName.mb_str(wxConvUTF8), NC_UNLIMITED, &DimId);
        if(m_status) HandleErrorNetcdf();
//        DimSize = 0;
    } else {
        m_status = nc_def_dim(m_fileId, DimName.mb_str(wxConvUTF8), DimSize, &DimId);
        if(m_status) HandleErrorNetcdf();
    }
}

void asFileNetcdf::DefVar(const wxString &VarName, nc_type DataType, const int &VarSize, const VectorStdString &DimNames)
{
    wxASSERT(m_opened);

    int VarId, DimId, NDims;
    VectorInt DimIds;

    // Check that the file is in define mode
    CheckDefModeOpen();

    NDims = (int) DimNames.size();

    for (int i=0; i<NDims; i++)
    {
        const char *DimNamesChar = DimNames[i].data ();
        m_status = nc_inq_dimid (m_fileId, DimNamesChar, &DimId);
        if(m_status) HandleErrorNetcdf();
        DimIds.push_back(DimId);
    }

    m_status = nc_def_var(m_fileId, VarName.mb_str(wxConvUTF8), DataType, VarSize, &DimIds[0], &VarId);
    if(m_status) HandleErrorNetcdf();
}

void asFileNetcdf::DefVarDeflate(const wxString &VarName, int shuffle, int deflateLevel)
{
    wxASSERT(m_opened);

    int VarId;

    m_status = nc_inq_varid (m_fileId, VarName.mb_str(wxConvUTF8), &VarId);
    if(m_status) HandleErrorNetcdf();

    m_status = nc_def_var_deflate(m_fileId, VarId, shuffle, 1, deflateLevel);
    if(m_status) HandleErrorNetcdf();
}

void asFileNetcdf::PutAtt(const wxString &AttName, const wxString &TextStr, const wxString &VarName)
{
    wxASSERT(m_opened);

    int AttId, VarId;

    wxCharBuffer buffer = TextStr.ToUTF8();

    // Check that the file is in define mode
    CheckDefModeOpen();

    // Check if global or not
    if ((VarName.IsEmpty()))
    {
        m_status = nc_put_att_text(m_fileId, NC_GLOBAL, AttName.mb_str(wxConvUTF8), strlen(buffer.data()), buffer.data());
        if(m_status) HandleErrorNetcdf();
        // Get the ID
        m_status = nc_inq_attid (m_fileId, NC_GLOBAL, AttName.mb_str(wxConvUTF8), &AttId);
        if(m_status) HandleErrorNetcdf();
    } else {
        m_status = nc_inq_varid (m_fileId, VarName.mb_str(wxConvUTF8), &VarId);
        if(m_status) HandleErrorNetcdf();
        m_status = nc_put_att_text(m_fileId, VarId, AttName.mb_str(wxConvUTF8), strlen(buffer.data()), buffer.data());
        if(m_status) HandleErrorNetcdf();
        // Get the ID
        m_status = nc_inq_attid (m_fileId, VarId, AttName.mb_str(wxConvUTF8), &AttId);
        if(m_status) HandleErrorNetcdf();
    }
}

void asFileNetcdf::PutAtt(const wxString &AttName, const short* attrValue, size_t Length, const wxString &VarName)
{
    wxASSERT(m_opened);

    int AttId, VarId;

    // Check that the file is in define mode
    CheckDefModeOpen();

    // Check if global or not
    if(VarName.IsEmpty())
    {
        m_status = nc_put_att_short (m_fileId, NC_GLOBAL, AttName.mb_str(wxConvUTF8), NC_SHORT, Length, attrValue);
        if(m_status) HandleErrorNetcdf();
        // Get the ID
        m_status = nc_inq_attid (m_fileId, NC_GLOBAL, AttName.mb_str(wxConvUTF8), &AttId);
        if(m_status) HandleErrorNetcdf();
    } else {
        m_status = nc_inq_varid (m_fileId, VarName.mb_str(wxConvUTF8), &VarId);
        if(m_status) HandleErrorNetcdf();
        m_status = nc_put_att_short (m_fileId, VarId, AttName.mb_str(wxConvUTF8), NC_SHORT, Length, attrValue);
        if(m_status) HandleErrorNetcdf();
        // Get the ID
        m_status = nc_inq_attid (m_fileId, VarId, AttName.mb_str(wxConvUTF8), &AttId);
        if(m_status) HandleErrorNetcdf();
    }
}

void asFileNetcdf::PutAtt(const wxString &AttName, const int* attrValue, size_t Length, const wxString &VarName)
{
    wxASSERT(m_opened);

    int AttId, VarId;

    // Check that the file is in define mode
    CheckDefModeOpen();

    // Check if global or not
    if(VarName.IsEmpty())
    {
        m_status = nc_put_att_int (m_fileId, NC_GLOBAL, AttName.mb_str(wxConvUTF8), NC_INT, Length, attrValue);
        if(m_status) HandleErrorNetcdf();
        // Get the ID
        m_status = nc_inq_attid (m_fileId, NC_GLOBAL, AttName.mb_str(wxConvUTF8), &AttId);
        if(m_status) HandleErrorNetcdf();
    } else {
        m_status = nc_inq_varid (m_fileId, VarName.mb_str(wxConvUTF8), &VarId);
        if(m_status) HandleErrorNetcdf();
        m_status = nc_put_att_int (m_fileId, VarId, AttName.mb_str(wxConvUTF8), NC_INT, Length, attrValue);
        if(m_status) HandleErrorNetcdf();
        // Get the ID
        m_status = nc_inq_attid (m_fileId, VarId, AttName.mb_str(wxConvUTF8), &AttId);
        if(m_status) HandleErrorNetcdf();
    }
}

void asFileNetcdf::PutAtt(const wxString &AttName, const float* attrValue, size_t Length, const wxString &VarName)
{
    wxASSERT(m_opened);

    int AttId, VarId;

    // Check that the file is in define mode
    CheckDefModeOpen();

    // Check if global or not
    if(VarName.IsEmpty())
    {
        m_status = nc_put_att_float (m_fileId, NC_GLOBAL, AttName.mb_str(wxConvUTF8), NC_FLOAT, Length, attrValue);
        if(m_status) HandleErrorNetcdf();
        // Get the ID
        m_status = nc_inq_attid (m_fileId, NC_GLOBAL, AttName.mb_str(wxConvUTF8), &AttId);
        if(m_status) HandleErrorNetcdf();
    } else {
        m_status = nc_inq_varid (m_fileId, VarName.mb_str(wxConvUTF8), &VarId);
        if(m_status) HandleErrorNetcdf();
        m_status = nc_put_att_float (m_fileId, VarId, AttName.mb_str(wxConvUTF8), NC_FLOAT, Length, attrValue);
        if(m_status) HandleErrorNetcdf();
        // Get the ID
        m_status = nc_inq_attid (m_fileId, VarId, AttName.mb_str(wxConvUTF8), &AttId);
        if(m_status) HandleErrorNetcdf();
    }
}

void asFileNetcdf::PutAtt(const wxString &AttName, const double* attrValue, size_t Length, const wxString &VarName)
{
    wxASSERT(m_opened);

    int AttId, VarId;

    // Check that the file is in define mode
    CheckDefModeOpen();

    // Check if global or not
    if(VarName.IsEmpty())
    {
        m_status = nc_put_att_double (m_fileId, NC_GLOBAL, AttName.mb_str(wxConvUTF8), NC_DOUBLE, Length, attrValue);
        if(m_status) HandleErrorNetcdf();
        // Get the ID
        m_status = nc_inq_attid (m_fileId, NC_GLOBAL, AttName.mb_str(wxConvUTF8), &AttId);
        if(m_status) HandleErrorNetcdf();
    } else {
        m_status = nc_inq_varid (m_fileId, VarName.mb_str(wxConvUTF8), &VarId);
        if(m_status) HandleErrorNetcdf();
        m_status = nc_put_att_double (m_fileId, VarId, AttName.mb_str(wxConvUTF8), NC_DOUBLE, Length, attrValue);
        if(m_status) HandleErrorNetcdf();
        // Get the ID
        m_status = nc_inq_attid (m_fileId, VarId, AttName.mb_str(wxConvUTF8), &AttId);
        if(m_status) HandleErrorNetcdf();
    }
}

void asFileNetcdf::PutVarArray(const wxString &VarName, const size_t* ArrStart, const size_t* ArrCount, const short* pData)
{
    wxASSERT(m_opened);

    int VarId;

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get Var ID
    m_status = nc_inq_varid (m_fileId, VarName.mb_str(wxConvUTF8), &VarId);
    if(m_status) HandleErrorNetcdf();
    // Write data
    m_status = nc_put_vara_short(m_fileId, VarId, ArrStart, ArrCount, pData);
    if(m_status) HandleErrorNetcdf();

}

void asFileNetcdf::PutVarArray(const wxString &VarName, const size_t* ArrStart, const size_t* ArrCount, const int* pData)
{
    wxASSERT(m_opened);

    int VarId;

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get Var ID
    m_status = nc_inq_varid (m_fileId, VarName.mb_str(wxConvUTF8), &VarId);
    if(m_status) HandleErrorNetcdf();
    // Write data
    m_status = nc_put_vara_int(m_fileId, VarId, ArrStart, ArrCount, pData);
    if(m_status) HandleErrorNetcdf();

}

void asFileNetcdf::PutVarArray(const wxString &VarName, const size_t* ArrStart, const size_t* ArrCount, const float* pData)
{
    wxASSERT(m_opened);

    int VarId;

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get Var ID
    m_status = nc_inq_varid (m_fileId, VarName.mb_str(wxConvUTF8), &VarId);
    if(m_status) HandleErrorNetcdf();
    // Write data
    m_status = nc_put_vara_float(m_fileId, VarId, ArrStart, ArrCount, pData);
    if(m_status) HandleErrorNetcdf();

}

void asFileNetcdf::PutVarArray(const wxString &VarName, const size_t* ArrStart, const size_t* ArrCount, const double* pData)
{
    wxASSERT(m_opened);

    int VarId;

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get Var ID
    m_status = nc_inq_varid (m_fileId, VarName.mb_str(wxConvUTF8), &VarId);
    if(m_status) HandleErrorNetcdf();
    // Write data
    m_status = nc_put_vara_double(m_fileId, VarId, ArrStart, ArrCount, pData);
    if(m_status) HandleErrorNetcdf();

}

void asFileNetcdf::PutVarArray(const wxString &VarName, const size_t* ArrStart, const size_t* ArrCount, const void* pData)
{
    wxASSERT(m_opened);

    int VarId;

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get Var ID
    m_status = nc_inq_varid (m_fileId, VarName.mb_str(wxConvUTF8), &VarId);
    if(m_status) HandleErrorNetcdf();
    // Write data
    m_status = nc_put_vara(m_fileId, VarId, ArrStart, ArrCount, pData);
    if(m_status) HandleErrorNetcdf();

}

void asFileNetcdf::PutVarArray(const wxString &VarName, const size_t* ArrStart, const size_t* ArrCount, const wxString* pData, const size_t TotSize)
{
    wxASSERT(m_opened);

    // From http://bytes.com/topic/c/answers/127614-best-way-copy-vector-string-char
    // Allocate memory for an array of character strings
    char** cstr = new char*[TotSize];

    // For each string, allocate memory in the character array and copy
    for (unsigned long i=0; i<TotSize; i++)
    {
        wxString valStr = *(pData+i);
        size_t length = valStr.Length();
        cstr[i] = new char[length+1];
		std::string valStdStr = (std::string)valStr.mb_str(wxConvUTF8);
        strncpy(cstr[i], valStdStr.c_str(), length);
        cstr[i][length]='\0';
    }

    int VarId;

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get Var ID
    m_status = nc_inq_varid (m_fileId, VarName.mb_str(wxConvUTF8), &VarId);
    if(m_status) HandleErrorNetcdf();
    // Write data
    m_status = nc_put_vara_string(m_fileId, VarId, ArrStart, ArrCount, (const char**)cstr);
    if(m_status) HandleErrorNetcdf();

    // Free dynamic memory
    for (unsigned long i=0; i<TotSize; i++) delete[] cstr[i];
    delete[] cstr;

}

void asFileNetcdf::CheckDefModeOpen()
{
    wxASSERT(m_opened);

    if(!m_defineMode)
    {
        StartDef();
    }
}

void asFileNetcdf::CheckDefModeClosed()
{
    if(m_defineMode)
    {
        EndDef();
    }
}

void asFileNetcdf::StartDef()
{
    wxASSERT(m_opened);

    m_status = nc_redef(m_fileId);
    if(m_status) HandleErrorNetcdf();
    m_defineMode = false;
}

void asFileNetcdf::EndDef()
{
    wxASSERT(m_opened);

    m_status = nc_enddef(m_fileId);
    if(m_status) HandleErrorNetcdf();
    m_defineMode = false;
    ParseStruct();
}

int asFileNetcdf::GetDimId(const wxString &DimName)
{
    wxASSERT(m_opened);

    int id = asNOT_FOUND;

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get the variable id
    for (int i_dim=0; i_dim<m_struct.NDims; i_dim++)
    {
        if (m_struct.Dims[i_dim].Name.IsSameAs(DimName))
        {
            id = m_struct.Dims[i_dim].Id;
        }
    }

    if (id==asNOT_FOUND) asLogWarning(wxString::Format(_("The desired variable doesn't exist: %s"), DimName));

    return id;
}

int asFileNetcdf::GetVarId(const wxString &VarName)
{
    wxASSERT(m_opened);

    int id = asNOT_FOUND;

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get the variable id
    for (int i_var=0; i_var<m_struct.NVars; i_var++)
    {
        if (m_struct.Vars[i_var].Name.IsSameAs(VarName))
        {
            id = m_struct.Vars[i_var].Id;
        }
    }

    if (id==asNOT_FOUND) asLogWarning(wxString::Format(_("The desired variable doesn't exist: %s"), VarName));

    return id;
}

int asFileNetcdf::GetAttId(const wxString &AttName, const wxString &VarName)
{
    wxASSERT(m_opened);

    int id = asNOT_FOUND;

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get the attribute id
    if (VarName.IsEmpty()) { // Global attribute
        for (int i_att=0; i_att<m_struct.NAtts; i_att++)
        {
            if (m_struct.Atts[i_att].Name.IsSameAs(AttName))
            {
                id = m_struct.Atts[i_att].Id;
            }
        }
    } else { // Variable attribute
        int varid = GetVarId(VarName);
        if (varid==asNOT_FOUND) return asNOT_FOUND;
        for (int i_att=0; i_att<m_struct.Vars[varid].NAtts; i_att++)
        {
            if (m_struct.Vars[varid].Atts[i_att].Name.IsSameAs(AttName))
            {
                id = m_struct.Vars[varid].Atts[i_att].Id;
            }
        }
    }

    if (id==asNOT_FOUND) asLogMessage(wxString::Format(_("The desired attribute doesn't exist: %s"), AttName));

    return id;
}

short asFileNetcdf::GetAttShort(const wxString &AttName, const wxString &VarName)
{
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Check that the structure already exists
    if (sizeof(m_struct)==0) ParseStruct();

    // Check if global attribute or variable attribute
    if (VarName.IsEmpty()) { // Global attribute
        int attid = GetAttId(AttName);
        if (attid==asNOT_FOUND) asThrowException(_("Cannot find the desired attribute in the netCDF file."));
        nc_type nctype = m_struct.Atts[attid].Type;

        // Check the given type
        if(nctype==NC_INT)
        {
            return (short)*(int*)m_struct.Atts[attid].pValue;
        }
        else if(nctype!=NC_SHORT)
        {
            asThrowException(wxString::Format(_("The attribute (%s) type (%d) in file doesn't match the desired type (%d)."), AttName, (int)nctype, (int)NC_SHORT ));
        }

        // Get value
        return *(short*)m_struct.Atts[attid].pValue;

    } else { // Variable attribute
        int varid = GetVarId(VarName);
        if (varid==asNOT_FOUND) asThrowException(_("Cannot find the desired variable in the netCDF file."));
        int attid = GetAttId(AttName, VarName);
        if (attid==asNOT_FOUND) asThrowException(_("Cannot find the desired attribute in the netCDF file."));
        nc_type nctype = m_struct.Vars[varid].Atts[attid].Type;

        // Check the given type
        if(nctype==NC_INT)
        {
            return (short)*(int*)m_struct.Vars[varid].Atts[attid].pValue;
        }
        else if(nctype!=NC_SHORT)
        {
            asThrowException(wxString::Format(_("The attribute (%s.%s) type (%d) in file doesn't match the desired type (%d)."), VarName, AttName, (int)nctype, (int)NC_SHORT ));
        }

        // Get value
        return *(short*)m_struct.Vars[varid].Atts[attid].pValue;
    }

}

int asFileNetcdf::GetAttInt(const wxString &AttName, const wxString &VarName)
{
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Check that the structure already exists
    if (sizeof(m_struct)==0) ParseStruct();

    // Check if global attribute or variable attribute
    if (VarName.IsEmpty()) { // Global attribute
        int attid = GetAttId(AttName);
        if (attid==asNOT_FOUND) asThrowException(_("Cannot find the desired attribute in the netCDF file."));
        nc_type nctype = m_struct.Atts[attid].Type;

        // Check the given type
        if(nctype==NC_SHORT)
        {
            return (int)*(short*)m_struct.Atts[attid].pValue;
        }
        else if(nctype!=NC_INT)
        {
            asThrowException(wxString::Format(_("The attribute (%s) type (%d) in file doesn't match the desired type (%d)."), AttName, (int)nctype, (int)NC_INT ));
        }

        // Get value
        return *(int*)m_struct.Atts[attid].pValue;

    } else { // Variable attribute
        int varid = GetVarId(VarName);
        if (varid==asNOT_FOUND) asThrowException(_("Cannot find the desired variable in the netCDF file."));
        int attid = GetAttId(AttName, VarName);
        if (attid==asNOT_FOUND) asThrowException(_("Cannot find the desired attribute in the netCDF file."));
        nc_type nctype = m_struct.Vars[varid].Atts[attid].Type;

        // Check the given type
        if(nctype==NC_SHORT)
        {
            return (int)*(short*)m_struct.Vars[varid].Atts[attid].pValue;
        }
        else if(nctype!=NC_INT)
        {
            asThrowException(wxString::Format(_("The attribute (%s.%s) type (%d) in file doesn't match the desired type (%d)."), VarName, AttName, (int)nctype, (int)NC_INT ));
        }

        // Get value
        return *(int*)m_struct.Vars[varid].Atts[attid].pValue;
    }

}

float asFileNetcdf::GetAttFloat(const wxString &AttName, const wxString &VarName)
{
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Check that the structure already exists
    if (sizeof(m_struct)==0) ParseStruct();

    // Check if global attribute or variable attribute
    if (VarName.IsEmpty()) { // Global attribute
        int attid = GetAttId(AttName);
        if (attid==asNOT_FOUND) return NaNFloat;
        nc_type nctype = m_struct.Atts[attid].Type;

        // Check the given type
        if(nctype==NC_DOUBLE)
        {
            return (float)*(double*)m_struct.Atts[attid].pValue;
        }
        else if(nctype!=NC_FLOAT)
        {
            asThrowException(wxString::Format(_("The attribute (%s) type (%d) in file doesn't match the desired type (%d)."), AttName, (int)nctype, (int)NC_FLOAT ));
        }

        // Get value
        return *(float*)m_struct.Atts[attid].pValue;

    } else { // Variable attribute
        int varid = GetVarId(VarName);
        if (varid==asNOT_FOUND) return NaNFloat;
        int attid = GetAttId(AttName, VarName);
        if (attid==asNOT_FOUND) return NaNFloat;
        nc_type nctype = m_struct.Vars[varid].Atts[attid].Type;

        // Check the given type
        if(nctype==NC_DOUBLE)
        {
            return (float)*(double*)m_struct.Vars[varid].Atts[attid].pValue;
        }
        else if(nctype!=NC_FLOAT)
        {
            asThrowException(wxString::Format(_("The attribute (%s.%s) type (%d) in file doesn't match the desired type (%d)."), VarName, AttName, (int)nctype, (int)NC_FLOAT ));
        }

        // Get value
        return *(float*)m_struct.Vars[varid].Atts[attid].pValue;
    }

}

double asFileNetcdf::GetAttDouble(const wxString &AttName, const wxString &VarName)
{
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Check that the structure already exists
    if (sizeof(m_struct)==0) ParseStruct();

    // Check if global attribute or variable attribute
    if (VarName.IsEmpty()) { // Global attribute
        int attid = GetAttId(AttName);
        if (attid==asNOT_FOUND) return NaNDouble;
        nc_type nctype = m_struct.Atts[attid].Type;

        // Check the given type
        if(nctype==NC_FLOAT)
        {
            return (double)*(float*)m_struct.Atts[attid].pValue;
        }
        else if(nctype!=NC_DOUBLE)
        {
            asThrowException(wxString::Format(_("The attribute (%s) type (%d) in file doesn't match the desired type (%d)."), AttName, (int)nctype, (int)NC_DOUBLE ));
        }

        // Get value
        return *(double*)m_struct.Atts[attid].pValue;

    } else { // Variable attribute
        int varid = GetVarId(VarName);
        if (varid==asNOT_FOUND) return NaNDouble;
        int attid = GetAttId(AttName, VarName);
        if (attid==asNOT_FOUND) return NaNDouble;
        nc_type nctype = m_struct.Vars[varid].Atts[attid].Type;

        // Check the given type
        if(nctype==NC_FLOAT)
        {
            return (double)*(float*)m_struct.Vars[varid].Atts[attid].pValue;
        }
        else if(nctype!=NC_DOUBLE)
        {
            asThrowException(wxString::Format(_("The attribute (%s.%s) type (%d) in file doesn't match the desired type (%d)."), VarName, AttName, (int)nctype, (int)NC_DOUBLE ));
        }

        // Get value
        return *(double*)m_struct.Vars[varid].Atts[attid].pValue;
    }

}

char asFileNetcdf::GetAttChar(const wxString &AttName, const wxString &VarName)
{
    wxASSERT(m_opened);

    char val;

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Check that the structure already exists
    if (sizeof(m_struct)==0) ParseStruct();

    // Check if global attribute or variable attribute
    if (VarName.IsEmpty()) { // Global attribute
        int attid = GetAttId(AttName);
        if (attid==asNOT_FOUND) asThrowException(_("Cannot find the desired attribute in the netCDF file."));
        nc_type nctype = m_struct.Atts[attid].Type;

        // Check the given type
        if(nctype!=NC_CHAR) asThrowException(wxString::Format(_("The attribute (%s) type (%d) in file doesn't match the desired type (%d)."), AttName, (int)nctype, (int)NC_CHAR ));

        // Get value
        val = *(char*)m_struct.Atts[attid].pValue;

    } else { // Variable attribute
        int varid = GetVarId(VarName);
        if (varid==asNOT_FOUND) asThrowException(_("Cannot find the desired variable in the netCDF file."));
        int attid = GetAttId(AttName, VarName);
        if (attid==asNOT_FOUND) asThrowException(_("Cannot find the desired attribute in the netCDF file."));
        nc_type nctype = m_struct.Vars[varid].Atts[attid].Type;

        // Check the given type
        if(nctype!=NC_CHAR) asThrowException(wxString::Format(_("The attribute (%s.%s) type (%d) in file doesn't match the desired type (%d)."), VarName, AttName, (int)nctype, (int)NC_CHAR ));

        // Get value
        val = *(char*)m_struct.Vars[varid].Atts[attid].pValue;
    }

    return val;
}

wxString asFileNetcdf::GetAttString(const wxString &AttName, const wxString &VarName)
{
    wxASSERT(m_opened);

    size_t len;
    wxString attrValue;

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Check that the structure already exists
    if (sizeof(m_struct)==0) ParseStruct();

    // Check if global attribute or variable attribute
    if (VarName.IsEmpty()) { // Global attribute
        int attid = GetAttId(AttName);
        if (attid==asNOT_FOUND) return wxEmptyString;

        // Allocate
        len = m_struct.Atts[attid].Length;
        char *text = new char[len + 1]; /* + 1 for trailing null */

        // Check the given type
        nc_type nctype = m_struct.Atts[attid].Type;
        if(nctype!=NC_CHAR)
        {
            wxDELETE(text);
            asThrowException(wxString::Format(_("The attribute (%s) type (%d) in file doesn't match the desired type (%d)."), AttName, (int)nctype, (int)NC_CHAR ));
        }

        // Get value
        m_status = nc_get_att_text (m_fileId, NC_GLOBAL, AttName.mb_str(wxConvUTF8), text);
        if(m_status) HandleErrorNetcdf();

        text[len] = '\0';

        // Copy into a wxString
        attrValue = wxString(text, wxConvUTF8);
        wxASSERT(!attrValue.IsEmpty());
        attrValue.Remove(len); // Remove the stuff after the end of the string
        wxASSERT(!attrValue.IsEmpty());
        wxDELETE(text);

    } else { // Variable attribute
        int varid = GetVarId(VarName);
        if (varid==asNOT_FOUND) return wxEmptyString;
        int attid = GetAttId(AttName, VarName);
        if (attid==asNOT_FOUND) return wxEmptyString;

        // Allocate
        len = m_struct.Vars[varid].Atts[attid].Length;
        char *text = new char[len + 1]; /* + 1 for trailing null */

        // Check the given type
        nc_type nctype = m_struct.Vars[varid].Atts[attid].Type;
        if(nctype!=NC_CHAR)
        {
            wxDELETE(text);
            asThrowException(wxString::Format(_("The attribute (%s.%s) type (%d) in file doesn't match the desired type (%d)."), VarName, AttName, (int)nctype, (int)NC_CHAR ));
        }

        // Get value
        m_status = nc_get_att_text (m_fileId, varid, AttName.mb_str(wxConvUTF8), text);
        if(m_status) HandleErrorNetcdf();

        text[len] = '\0';

        // Copy into a wxString
        attrValue = wxString(text);
        wxASSERT(!attrValue.IsEmpty());
        attrValue.Remove(len); // Remove the stuff after the end of the string
        wxASSERT(!attrValue.IsEmpty());
        wxDELETE(text);
    }

    return attrValue;
}

size_t asFileNetcdf::GetDimLength(const wxString &DimName)
{
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    size_t len = 0;
    int dimid = GetDimId(DimName);
    if (dimid==asNOT_FOUND) return 0;

    // Get the variable length
    len = m_struct.Dims[dimid].Length;

    return len;
}

size_t asFileNetcdf::GetVarLength(const wxString &VarName)
{
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    size_t len = 0;
    int varid = GetVarId(VarName);
    if (varid==asNOT_FOUND) return 0;

    // Get the variable length
    len = m_struct.Vars[varid].Length;

    return len;
}

void asFileNetcdf::GetVar(const wxString &VarName, short* pValue)
{
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Check that the structure already exists
    if (sizeof(m_struct)==0) ParseStruct();

    // Get the variable value
    int varid = GetVarId(VarName);
    if (varid==asNOT_FOUND) asThrowException(_("Cannot get the desired variable from the netCDF file."));

    // Check the given type
    nc_type nctype = m_struct.Vars[varid].Type;
    if(nctype!=NC_SHORT) asThrowException(wxString::Format(_("The variable (%s) type (%d) in file doesn't match the desired type (%d)."), VarName, (int)nctype, (int)NC_SHORT ));

    // Get value
    m_status = nc_get_var_short (m_fileId, varid, pValue);
    if(m_status) HandleErrorNetcdf();
}

void asFileNetcdf::GetVar(const wxString &VarName, int* pValue)
{
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Check that the structure already exists
    if (sizeof(m_struct)==0) ParseStruct();

    // Get the variable value
    int varid = GetVarId(VarName);
    if (varid==asNOT_FOUND) asThrowException(_("Cannot get the desired variable from the netCDF file."));

    // Check the given type
    nc_type nctype = m_struct.Vars[varid].Type;
    if(nctype!=NC_INT) asThrowException(wxString::Format(_("The variable (%s) type (%d) in file doesn't match the desired type (%d)."), VarName, (int)nctype, (int)NC_INT ));

    // Get value
    m_status = nc_get_var_int (m_fileId, varid, pValue);
    if(m_status) HandleErrorNetcdf();
}

void asFileNetcdf::GetVar(const wxString &VarName, float* pValue)
{
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Check that the structure already exists
    if (sizeof(m_struct)==0) ParseStruct();

    // Get the variable value
    int varid = GetVarId(VarName);
    if (varid==asNOT_FOUND) asThrowException(_("Cannot get the desired variable from the netCDF file."));

    // Check the given type
    nc_type nctype = m_struct.Vars[varid].Type;
    if(nctype!=NC_FLOAT) asThrowException(wxString::Format(_("The variable (%s) type (%d) in file doesn't match the desired type (%d)."), VarName, (int)nctype, (int)NC_FLOAT ));

    // Get value
    m_status = nc_get_var_float (m_fileId, varid, pValue);
    if(m_status) HandleErrorNetcdf();
}

void asFileNetcdf::GetVar(const wxString &VarName, double* pValue)
{
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Check that the structure already exists
    if (sizeof(m_struct)==0) ParseStruct();

    // Get the variable value
    int varid = GetVarId(VarName);
    if (varid==asNOT_FOUND) asThrowException(_("Cannot get the desired variable from the netCDF file."));

    // Check the given type
    nc_type nctype = m_struct.Vars[varid].Type;
    if(nctype!=NC_DOUBLE) asThrowException(wxString::Format(_("The variable (%s) type (%d) in file doesn't match the desired type (%d)."), VarName, (int)nctype, (int)NC_DOUBLE ));

    // Get value
    m_status = nc_get_var_double (m_fileId, varid, pValue);
    if(m_status) HandleErrorNetcdf();
}

void asFileNetcdf::GetVar(const wxString &VarName, wxString* pValue, const size_t TotSize)
{
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Check that the structure already exists
    if (sizeof(m_struct)==0) ParseStruct();

    // Get the variable value
    int varid = GetVarId(VarName);
    if (varid==asNOT_FOUND) asThrowException(_("Cannot get the desired variable from the netCDF file."));

    // Check the given type
    nc_type nctype = m_struct.Vars[varid].Type;
    if(nctype!=NC_STRING) asThrowException(wxString::Format(_("The variable (%s) type (%d) in file doesn't match the desired type (%d)."), VarName, (int)nctype, (int)NC_STRING ));

    // Get value
    std::vector < char* > data(TotSize);
    m_status = nc_get_var_string (m_fileId, varid, &data[0]);
    if(m_status) HandleErrorNetcdf();

    // Set in the wxString array
    for (unsigned int i=0; i<TotSize; i++)
    {
		wxString val(data[i], wxConvUTF8);
        *(pValue+i) = val;
    }

}

short asFileNetcdf::GetVarOneShort(const wxString &VarName, size_t ArrIndex)
{
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Check that the structure already exists
    if (sizeof(m_struct)==0) ParseStruct();

    // Get the variable value
    int varid = GetVarId(VarName);
    if (varid==asNOT_FOUND) asThrowException(_("Cannot get the desired variable from the netCDF file."));

    // Check the given type
    nc_type nctype = m_struct.Vars[varid].Type;
    if(nctype!=NC_SHORT) asThrowException(wxString::Format(_("The variable (%s) type (%d) in file doesn't match the desired type (%d)."), VarName, (int)nctype, (int)NC_SHORT ));

    // Get value
    short val;
    m_status = nc_get_var1_short (m_fileId, varid, &ArrIndex, &val);
    if(m_status) HandleErrorNetcdf();

    return val;
}

int asFileNetcdf::GetVarOneInt(const wxString &VarName, size_t ArrIndex)
{
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Check that the structure already exists
    if (sizeof(m_struct)==0) ParseStruct();

    // Get the variable value
    int varid = GetVarId(VarName);
    if (varid==asNOT_FOUND) asThrowException(_("Cannot get the desired variable from the netCDF file."));

    // Check the given type
    nc_type nctype = m_struct.Vars[varid].Type;
    if(nctype!=NC_INT) asThrowException(wxString::Format(_("The variable (%s) type (%d) in file doesn't match the desired type (%d)."), VarName, (int)nctype, (int)NC_INT ));

    // Get value
    int val;
    m_status = nc_get_var1_int (m_fileId, varid, &ArrIndex, &val);
    if(m_status) HandleErrorNetcdf();

    return val;
}

float asFileNetcdf::GetVarOneFloat(const wxString &VarName, size_t ArrIndex)
{
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Check that the structure already exists
    if (sizeof(m_struct)==0) ParseStruct();

    // Get the variable value
    int varid = GetVarId(VarName);
    if (varid==asNOT_FOUND) asThrowException(_("Cannot get the desired variable from the netCDF file."));

    // Check the given type
    nc_type nctype = m_struct.Vars[varid].Type;
    if(nctype!=NC_FLOAT) asThrowException(wxString::Format(_("The variable (%s) type (%d) in file doesn't match the desired type (%d)."), VarName, (int)nctype, (int)NC_FLOAT ));

    // Get value
    float val;
    m_status = nc_get_var1_float (m_fileId, varid, &ArrIndex, &val);
    if(m_status) HandleErrorNetcdf();

    return val;
}

double asFileNetcdf::GetVarOneDouble(const wxString &VarName, size_t ArrIndex)
{
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Check that the structure already exists
    if (sizeof(m_struct)==0) ParseStruct();

    // Get the variable value
    int varid = GetVarId(VarName);
    if (varid==asNOT_FOUND) asThrowException(_("Cannot get the desired variable from the netCDF file."));

    // Check the given type
    nc_type nctype = m_struct.Vars[varid].Type;
    if(nctype!=NC_DOUBLE) asThrowException(wxString::Format(_("The variable (%s) type (%d) in file doesn't match the desired type (%d)."), VarName, (int)nctype, (int)NC_DOUBLE ));

    // Get value
    double val;
    m_status = nc_get_var1_double (m_fileId, varid, &ArrIndex, &val);
    if(m_status) HandleErrorNetcdf();

    return val;
}

void asFileNetcdf::GetVarArray(const wxString &VarName, const size_t IndexStart[], const size_t IndexCount[], short* pValue)
{
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Check that the structure already exists
    if (sizeof(m_struct)==0) ParseStruct();

    // Get the variable value
    int varid = GetVarId(VarName);
    if (varid==asNOT_FOUND) asThrowException(_("Cannot get the desired variable from the netCDF file."));

    // Check the given type
    nc_type nctype = m_struct.Vars[varid].Type;
    if(nctype!=NC_SHORT) asThrowException(wxString::Format(_("The variable (%s) type (%d) in file doesn't match the desired type (%d)."), VarName, (int)nctype, (int)NC_SHORT ));

    // Get value
    m_status = nc_get_vara_short (m_fileId, varid, IndexStart, IndexCount, pValue);
    if(m_status)
    {
        int arrSize = m_struct.Vars[varid].NDims;
        wxString data = wxEmptyString;
        for (int i=0; i<arrSize; i++)
        {
            data.Append(wxString::Format("IndexStart[%d]=%d ", i, (int)IndexStart[i]));
            data.Append(wxString::Format("IndexCount[%d]=%d ", i, (int)IndexCount[i]));
        }
        wxString msg = _("Requested indices: ") + data;
        asLogError(msg);
        HandleErrorNetcdf();
    }
}

void asFileNetcdf::GetVarArray(const wxString &VarName, const size_t IndexStart[], const size_t IndexCount[], int* pValue)
{
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Check that the structure already exists
    if (sizeof(m_struct)==0) ParseStruct();

    // Get the variable value
    int varid = GetVarId(VarName);
    if (varid==asNOT_FOUND) asThrowException(_("Cannot get the desired variable from the netCDF file."));

    // Check the given type
    nc_type nctype = m_struct.Vars[varid].Type;
    if(nctype!=NC_INT) asThrowException(wxString::Format(_("The variable (%s) type (%d) in file doesn't match the desired type (%d)."), VarName, (int)nctype, (int)NC_INT ));

    // Get value
    m_status = nc_get_vara_int (m_fileId, varid, IndexStart, IndexCount, pValue);
    if(m_status)
    {
        int arrSize = m_struct.Vars[varid].NDims;
        wxString data = wxEmptyString;
        for (int i=0; i<arrSize; i++)
        {
            data.Append(wxString::Format("IndexStart[%d]=%d ", i, (int)IndexStart[i]));
            data.Append(wxString::Format("IndexCount[%d]=%d ", i, (int)IndexCount[i]));
        }
        wxString msg = _("Requested indices: ") + data;
        asLogError(msg);
        HandleErrorNetcdf();
    }
}

void asFileNetcdf::GetVarArray(const wxString &VarName, const size_t IndexStart[], const size_t IndexCount[], float* pValue)
{
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Check that the structure already exists
    if (sizeof(m_struct)==0) ParseStruct();

    // Get the variable value
    int varid = GetVarId(VarName);
    if (varid==asNOT_FOUND) asThrowException(_("Cannot get the desired variable from the netCDF file."));

    // Check the given type
    nc_type nctype = m_struct.Vars[varid].Type;
    if(nctype!=NC_FLOAT) asThrowException(wxString::Format(_("The variable (%s) type (%d) in file doesn't match the desired type (%d)."), VarName, (int)nctype, (int)NC_FLOAT ));

    // Get value
    m_status = nc_get_vara_float (m_fileId, varid, IndexStart, IndexCount, pValue);
    if(m_status)
    {
        int arrSize = m_struct.Vars[varid].NDims;
        wxString data = wxEmptyString;
        for (int i=0; i<arrSize; i++)
        {
            data.Append(wxString::Format("IndexStart[%d]=%d ", i, (int)IndexStart[i]));
            data.Append(wxString::Format("IndexCount[%d]=%d ", i, (int)IndexCount[i]));
        }
        wxString msg = _("Requested indices: ") + data;
        asLogError(msg);
        HandleErrorNetcdf();
    }
}

void asFileNetcdf::GetVarArray(const wxString &VarName, const size_t IndexStart[], const size_t IndexCount[], double* pValue)
{
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Check that the structure already exists
    if (sizeof(m_struct)==0) ParseStruct();

    // Get the variable value
    int varid = GetVarId(VarName);
    if (varid==asNOT_FOUND) asThrowException(_("Cannot get the desired variable from the netCDF file."));

    // Check the given type
    nc_type nctype = m_struct.Vars[varid].Type;
    if(nctype!=NC_DOUBLE) asThrowException(wxString::Format(_("The variable (%s) type (%d) in file doesn't match the desired type (%d)."), VarName, (int)nctype, (int)NC_DOUBLE ));

    // Get value
    m_status = nc_get_vara_double (m_fileId, varid, IndexStart, IndexCount, pValue);
    if(m_status)
    {
        int arrSize = m_struct.Vars[varid].NDims;
        wxString data = wxEmptyString;
        for (int i=0; i<arrSize; i++)
        {
            data.Append(wxString::Format("IndexStart[%d]=%d ", i, (int)IndexStart[i]));
            data.Append(wxString::Format("IndexCount[%d]=%d ", i, (int)IndexCount[i]));
        }
        wxString msg = _("Requested indices: ") + data;
        asLogError(msg);
        HandleErrorNetcdf();
    }
}

void asFileNetcdf::GetVarSample(const wxString &VarName, const size_t IndexStart[], const size_t IndexCount[], const ptrdiff_t IndexStride[], short* pValue)
{
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Check that the structure already exists
    if (sizeof(m_struct)==0) ParseStruct();

    // Get the variable value
    int varid = GetVarId(VarName);
    if (varid==asNOT_FOUND) asThrowException(_("Cannot get the desired variable from the netCDF file."));

    // Check the given type
    nc_type nctype = m_struct.Vars[varid].Type;
    if(nctype!=NC_SHORT) asThrowException(wxString::Format(_("The variable (%s) type (%d) in file doesn't match the desired type (%d)."), VarName, (int)nctype, (int)NC_SHORT ));

    // Get value
    m_status = nc_get_vars_short (m_fileId, varid, IndexStart, IndexCount, IndexStride, pValue);
    if(m_status)
    {
        int arrSize = m_struct.Vars[varid].NDims;
        wxString data = wxEmptyString;
        for (int i=0; i<arrSize; i++)
        {
            data.Append(wxString::Format("IndexStart[%d]=%d ", i, (int)IndexStart[i]));
            data.Append(wxString::Format("IndexCount[%d]=%d ", i, (int)IndexCount[i]));
            data.Append(wxString::Format("IndexStride[%d]=%d ", i, (int)IndexStride[i]));
        }
        wxString msg = _("Requested indices: ") + data;
        asLogError(msg);
        HandleErrorNetcdf();
    }
}

void asFileNetcdf::GetVarSample(const wxString &VarName, const size_t IndexStart[], const size_t IndexCount[], const ptrdiff_t IndexStride[], int* pValue)
{
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Check that the structure already exists
    if (sizeof(m_struct)==0) ParseStruct();

    // Get the variable value
    int varid = GetVarId(VarName);
    if (varid==asNOT_FOUND) asThrowException(_("Cannot get the desired variable from the netCDF file."));

    // Check the given type
    nc_type nctype = m_struct.Vars[varid].Type;
    if(nctype!=NC_INT) asThrowException(wxString::Format(_("The variable (%s) type (%d) in file doesn't match the desired type (%d)."), VarName, (int)nctype, (int)NC_INT ));

    // Get value
    m_status = nc_get_vars_int (m_fileId, varid, IndexStart, IndexCount, IndexStride, pValue);
    if(m_status)
    {
        int arrSize = m_struct.Vars[varid].NDims;
        wxString data = wxEmptyString;
        for (int i=0; i<arrSize; i++)
        {
            data.Append(wxString::Format("IndexStart[%d]=%d ", i, (int)IndexStart[i]));
            data.Append(wxString::Format("IndexCount[%d]=%d ", i, (int)IndexCount[i]));
            data.Append(wxString::Format("IndexStride[%d]=%d ", i, (int)IndexStride[i]));
        }
        wxString msg = _("Requested indices: ") + data;
        asLogError(msg);
        HandleErrorNetcdf();
    }
}

void asFileNetcdf::GetVarSample(const wxString &VarName, const size_t IndexStart[], const size_t IndexCount[], const ptrdiff_t IndexStride[], float* pValue)
{
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Check that the structure already exists
    if (sizeof(m_struct)==0) ParseStruct();

    // Get the variable value
    int varid = GetVarId(VarName);
    if (varid==asNOT_FOUND) asThrowException(_("Cannot get the desired variable from the netCDF file."));

    // Check the given type. Allow the short type here.
    nc_type nctype = m_struct.Vars[varid].Type;
    if(nctype!=NC_FLOAT) asThrowException(wxString::Format(_("The variable (%s) type (%d) in file doesn't match the desired type (%d)."), VarName, (int)nctype, (int)NC_FLOAT ));

    // Get value
    m_status = nc_get_vars_float (m_fileId, varid, IndexStart, IndexCount, IndexStride, pValue);
    if(m_status)
    {
        int arrSize = m_struct.Vars[varid].NDims;
        wxString data = wxEmptyString;
        for (int i=0; i<arrSize; i++)
        {
            data.Append(wxString::Format("IndexStart[%d]=%d ", i, (int)IndexStart[i]));
            data.Append(wxString::Format("IndexCount[%d]=%d ", i, (int)IndexCount[i]));
            data.Append(wxString::Format("IndexStride[%d]=%d ", i, (int)IndexStride[i]));
        }
        wxString msg = _("Requested indices: ") + data;
        asLogError(msg);
        HandleErrorNetcdf();
    }
}

void asFileNetcdf::GetVarSample(const wxString &VarName, const size_t IndexStart[], const size_t IndexCount[], const ptrdiff_t IndexStride[], double* pValue)
{
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Check that the structure already exists
    if (sizeof(m_struct)==0) ParseStruct();

    // Get the variable value
    int varid = GetVarId(VarName);
    if (varid==asNOT_FOUND) asThrowException(_("Cannot get the desired variable from the netCDF file."));

    // Check the given type
    nc_type nctype = m_struct.Vars[varid].Type;
    if(nctype!=NC_DOUBLE) asThrowException(wxString::Format(_("The variable (%s) type (%d) in file doesn't match the desired type (%d)."), VarName, (int)nctype, (int)NC_DOUBLE ));

    // Get value
    m_status = nc_get_vars_double (m_fileId, varid, IndexStart, IndexCount, IndexStride, pValue);
    if(m_status)
    {
        int arrSize = m_struct.Vars[varid].NDims;
        wxString data = wxEmptyString;
        for (int i=0; i<arrSize; i++)
        {
            data.Append(wxString::Format("IndexStart[%d]=%d ", i, (int)IndexStart[i]));
            data.Append(wxString::Format("IndexCount[%d]=%d ", i, (int)IndexCount[i]));
            data.Append(wxString::Format("IndexStride[%d]=%d ", i, (int)IndexStride[i]));
        }
        wxString msg = _("Requested indices: ") + data;
        asLogError(msg);
        HandleErrorNetcdf();
    }
}

void asFileNetcdf::ClearStruct()
{
    for(unsigned int i_var=0; i_var<m_struct.Vars.size(); i_var++)
    {
        for(unsigned int i_att=0; i_att<m_struct.Vars[i_var].Atts.size(); i_att++)
        {
            if ( m_struct.Vars[i_var].Atts[i_att].pValue != NULL )
            {
                nc_type nctype = m_struct.Vars[i_var].Atts[i_att].Type;

                // Cleanup from http://stackoverflow.com/questions/206257/freeing-memory-allocated-to-an-array-of-void-pointers
                switch( nctype ) {
                    case NC_CHAR: // NC_CHAR - ISO/ASCII character
                    {
                        delete static_cast<char*>( m_struct.Vars[i_var].Atts[i_att].pValue);
                        break;
                    }

                    case NC_SHORT: // NC_SHORT - signed 2 byte integer
                    {
                        delete static_cast<short*>( m_struct.Vars[i_var].Atts[i_att].pValue);
                        break;
                    }

                    case NC_INT: // NC_INT - signed 4 byte integer
                    {
                        delete static_cast<int32_t*>( m_struct.Vars[i_var].Atts[i_att].pValue);
                        break;
                    }

                    case NC_INT64: // NC_INT64 - signed 8 byte integer
                    {
                        delete static_cast<int64_t*>( m_struct.Vars[i_var].Atts[i_att].pValue);
                        break;
                    }

                    case NC_FLOAT: // NC_FLOAT - single precision floating point number
                    {
                        delete static_cast<float*>( m_struct.Vars[i_var].Atts[i_att].pValue);
                        break;
                    }

                    case NC_DOUBLE: // NC_DOUBLE - double precision floating point number
                    {
                        delete static_cast<double*>( m_struct.Vars[i_var].Atts[i_att].pValue);
                        break;
                    }

                    default:
                        asThrowException(wxString::Format(_("NetCDF file: data type (%d) of attribute %s not taken into account in AtmoSwing."), nctype, m_struct.Vars[i_var].Atts[i_att].Name));
                        break;
                }

                m_struct.Vars[i_var].Atts[i_att].pValue = NULL;
            }
        }
    }

    for(unsigned int i_att=0; i_att<m_struct.Atts.size(); i_att++)
    {
        if ( m_struct.Atts[i_att].pValue != NULL )
        {
            nc_type nctype = m_struct.Atts[i_att].Type;

            switch( nctype ) {
                case NC_CHAR: // NC_CHAR - ISO/ASCII character
                {
                    delete static_cast<char*>( m_struct.Atts[i_att].pValue);
                    break;
                }

                case NC_SHORT: // NC_SHORT - signed 2 byte integer
                {
                    delete static_cast<short*>( m_struct.Atts[i_att].pValue);
                    break;
                }

                case NC_INT: // NC_INT - signed 4 byte integer
                {
                    delete static_cast<int32_t*>( m_struct.Atts[i_att].pValue);
                    break;
                }

                case NC_INT64: // NC_INT64 - signed 8 byte integer
                {
                    delete static_cast<int64_t*>( m_struct.Atts[i_att].pValue);
                    break;
                }

                case NC_FLOAT: // NC_FLOAT - single precision floating point number
                {
                    delete static_cast<float*>( m_struct.Atts[i_att].pValue);
                    break;
                }

                case NC_DOUBLE: // NC_DOUBLE - double precision floating point number
                {
                    delete static_cast<double*>( m_struct.Atts[i_att].pValue);
                    break;
                }

                default:
                    asThrowException(wxString::Format(_("NetCDF file: data type (%d) of attribute %s not taken into account in AtmoSwing."), nctype, m_struct.Atts[i_att].Name));
                    break;
            }

            m_struct.Atts[i_att].pValue = NULL;
        }
    }
}

bool asFileNetcdf::ParseStruct()
{
    int DimId, VarId, AttId, Format;
    char DimNameChar[NC_MAX_NAME+1], VarNameChar[NC_MAX_NAME+1], AttNameChar[NC_MAX_NAME+1];
    int UnlimDimIds[NC_MAX_DIMS], DimIds[NC_MAX_VAR_DIMS];

    // Clear current structure
    ClearStruct();

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Inquire about the NetCDF Dataset
    m_status = nc_inq (m_fileId, &m_struct.NDims, &m_struct.NVars, &m_struct.NAtts, &m_struct.UDimId);
    if(m_status) HandleErrorNetcdf();

    // Get the file format
    m_status = nc_inq_format (m_fileId, &Format);
    if(m_status) HandleErrorNetcdf();
    switch (Format)
    {
        case (NC_FORMAT_CLASSIC):
            m_struct.Format = Classic;
            break;
        case (NC_FORMAT_64BIT):
            m_struct.Format = Format64bit;
            break;
        case (NC_FORMAT_NETCDF4):
            m_struct.Format = Netcdf4;
            break;
        case (NC_FORMAT_NETCDF4_CLASSIC):
            m_struct.Format = Netcdf4Classic;
            break;
        default:
            asLogError(_("The NetCDF format is unknown"));
            return false;
    }

    // Create arrays to store the dimensions information
    m_struct.Dims.resize( m_struct.NDims );

    // Inquire about the dimensions
    for (DimId=0; DimId<m_struct.NDims; DimId++)
    {
        m_status = nc_inq_dim (m_fileId, DimId, DimNameChar, &m_struct.Dims[DimId].Length);
        if(m_status) HandleErrorNetcdf();
        m_struct.Dims[DimId].Id = DimId;
        wxString tmpName(DimNameChar, wxConvUTF8);
        m_struct.Dims[DimId].Name = tmpName;
    }

// FIXME (phorton#1#): Cannot get the Netcdf4 functions ??
    // Find all unlimited dimensions
/*    if(m_status = nc_inq_unlimdims(m_fileId, &m_struct.NUDims, NULL)) HandleErrorNetcdf();
    m_struct.UDimsIds.resize(m_struct.NUDims);
    if(m_status = nc_inq_unlimdims(m_fileId, &m_struct.NUDims, UnlimDimIds)) HandleErrorNetcdf();
    for (int i=0; i<m_struct.NUDims; i++)
    {
        m_struct.UDimsIds[i] = UnlimDimIds[i];
    }*/

    // Find 1 unlimited dimension
    m_struct.UDimsIds.resize(1);
    m_status = nc_inq_unlimdim(m_fileId, UnlimDimIds);
    if(m_status) HandleErrorNetcdf();
    m_struct.UDimsIds[0] = UnlimDimIds[0];

    // Resize array to store the global attributes
    m_struct.Atts.resize(m_struct.NAtts);

    // Get the global attributes
    for (AttId=0; AttId<m_struct.NAtts; AttId++)
    {
        // Get the attribute name
        m_status = nc_inq_attname(m_fileId, NC_GLOBAL, AttId, AttNameChar);
        if(m_status) HandleErrorNetcdf();
        m_struct.Atts[AttId].Id = AttId;
        wxString tmpName(AttNameChar, wxConvUTF8);
        m_struct.Atts[AttId].Name = tmpName;

        // Get the attribute type and length
        m_status = nc_inq_att (m_fileId, NC_GLOBAL, AttNameChar, &m_struct.Atts[AttId].Type, &m_struct.Atts[AttId].Length);
        if(m_status) HandleErrorNetcdf();
        size_t len = m_struct.Atts[AttId].Length;

        // Only store simple attributes
        if (len>1)
        {
            m_struct.Atts[AttId].pValue = NULL;
        }
        else
        {
            nc_type nctype = m_struct.Atts[AttId].Type;

            switch( nctype ) {
                case NC_CHAR: // NC_CHAR - ISO/ASCII character
                {
                    m_struct.Atts[AttId].pValue = new char();
                    break;
                }

                case NC_SHORT: // NC_SHORT - signed 2 byte integer
                {
                    m_struct.Atts[AttId].pValue = new short();
                    break;
                }

                case NC_INT: // NC_INT - signed 4 byte integer
                {
                    m_struct.Atts[AttId].pValue = new int32_t();
                    break;
                }

                case NC_INT64: // NC_INT64 - signed 8 byte integer
                {
                    m_struct.Atts[AttId].pValue = new int64_t();
                    break;
                }

                case NC_FLOAT: // NC_FLOAT - single precision floating point number
                {
                    m_struct.Atts[AttId].pValue = new float();
                    break;
                }

                case NC_DOUBLE: // NC_DOUBLE - double precision floating point number
                {
                    m_struct.Atts[AttId].pValue = new double();
                    break;
                }

                default:
                    asLogError(wxString::Format(_("NetCDF file: data type (%d) of attribute %s not taken into account in AtmoSwing."), nctype, m_struct.Atts[AttId].Name));
                    return false;
                    break;
            }

            // Get the attribute value
            m_status = nc_get_att (m_fileId, NC_GLOBAL, AttNameChar, m_struct.Atts[AttId].pValue);
            if(m_status) HandleErrorNetcdf();

        }
    }

    // Resize arrays to store the variables information
    m_struct.Vars.resize(m_struct.NVars);

    // Get information about the variables and get limited variables (1D)
    for (VarId=0; VarId<m_struct.NVars; VarId++)
    {
        m_status = nc_inq_var (m_fileId, VarId, VarNameChar, &m_struct.Vars[VarId].Type, &m_struct.Vars[VarId].NDims, DimIds, &m_struct.Vars[VarId].NAtts);
        if(m_status) HandleErrorNetcdf();
        m_struct.Vars[VarId].Id = VarId;
        wxString tmpName(VarNameChar, wxConvUTF8);
        m_struct.Vars[VarId].Name = tmpName;
        m_struct.Vars[VarId].Length = 0;

        m_struct.Vars[VarId].NDimIds.resize(m_struct.Vars[VarId].NDims);
        for (int j=0; j<m_struct.Vars[VarId].NDims; j++)
        {
            m_struct.Vars[VarId].NDimIds[j] = DimIds[j];
        }

        // Find the corresponding dimension to get its length
        for (DimId=0; DimId<m_struct.NDims; DimId++)
        {
            if (m_struct.Vars[VarId].Name.IsSameAs(m_struct.Dims[DimId].Name))
            {
                m_struct.Vars[VarId].Length = m_struct.Dims[DimId].Length;
            }
        }

        // Resize array to store the attributes information
        m_struct.Vars[VarId].Atts.resize( m_struct.Vars[VarId].NAtts );

        // Get the attributes information
        for (AttId=0; AttId<m_struct.Vars[VarId].NAtts; AttId++)
        {
            // Get the attribute name
            m_status = nc_inq_attname(m_fileId, VarId, AttId, AttNameChar);
            if(m_status) HandleErrorNetcdf();
            m_struct.Vars[VarId].Atts[AttId].Id = AttId;
            wxString tmpName(AttNameChar, wxConvUTF8);
            m_struct.Vars[VarId].Atts[AttId].Name = tmpName;

            // Get the attribute type and length
            m_status = nc_inq_att (m_fileId, VarId, AttNameChar, &m_struct.Vars[VarId].Atts[AttId].Type, &m_struct.Vars[VarId].Atts[AttId].Length);
            if(m_status) HandleErrorNetcdf();
            size_t len = m_struct.Vars[VarId].Atts[AttId].Length;
            // Only store simple attributes
            if (len>1)
            {
                m_struct.Vars[VarId].Atts[AttId].pValue = NULL;
            }
            else
            {
                nc_type nctype = m_struct.Vars[VarId].Atts[AttId].Type;

                switch( nctype ) {
                    case NC_CHAR: // NC_CHAR - ISO/ASCII character
                    {
                        m_struct.Vars[VarId].Atts[AttId].pValue = new char();
                        break;
                    }

                    case NC_SHORT: // NC_SHORT - signed 2 byte integer
                    {
                        m_struct.Vars[VarId].Atts[AttId].pValue = new short();
                        break;
                    }

                    case NC_INT: // NC_INT - signed 4 byte integer
                    {
                        m_struct.Vars[VarId].Atts[AttId].pValue = new int32_t();
                        break;
                    }

                    case NC_INT64: // NC_INT64 - signed 8 byte integer
                    {
                        m_struct.Vars[VarId].Atts[AttId].pValue = new int64_t();
                        break;
                    }

                    case NC_FLOAT: // NC_FLOAT - single precision floating point number
                    {
                        m_struct.Vars[VarId].Atts[AttId].pValue = new float();
                        break;
                    }

                    case NC_DOUBLE: // NC_DOUBLE - double precision floating point number
                    {
                        m_struct.Vars[VarId].Atts[AttId].pValue = new double();
                        break;
                    }

                    default:
                        asLogError(wxString::Format(_("NetCDF file: data type (%d) of attribute %s not taken into account in AtmoSwing."), nctype, m_struct.Vars[VarId].Atts[AttId].Name));
                        return false;
                        break;
                }

                // Get the attribute value
                m_status = nc_get_att (m_fileId, VarId, AttNameChar, m_struct.Vars[VarId].Atts[AttId].pValue);
                if(m_status) HandleErrorNetcdf();

            }
        }
    }

    return true;
}

size_t asFileNetcdf::GetVarLength(int &varid)
{
    wxASSERT(m_opened);

    // No previous checks necessary
    size_t len = 0;

    // Get the variable length
    len = m_struct.Vars[varid].Length;

    return len;
}
