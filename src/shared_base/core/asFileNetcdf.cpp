/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can read the License at http://opensource.org/licenses/CDDL-1.0
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL Header Notice in
 * each file and include the License file (licence.txt). If applicable,
 * add the following below this CDDL Header, with the fields enclosed
 * by brackets [] replaced by your own identifying information:
 * "Portions Copyright [year] [name of copyright owner]"
 *
 * The Original Software is AtmoSwing.
 * The Original Software was developed at the University of Lausanne.
 * All Rights Reserved.
 *
 */

/*
 * Portions Copyright 2008-2013 Pascal Horton, University of Lausanne.
 * Portions Copyright 2013-2015 Pascal Horton, Terranum.
 */

#include "asFileNetcdf.h"

asFileNetcdf::asFileNetcdf(const wxString& fileName, const FileMode& fileMode)
    : asFile(fileName, fileMode),
      m_fileId(0),
      m_status(0),
      m_defineMode(false) {
    m_struct.format = Classic;
}

asFileNetcdf::~asFileNetcdf() {
    Close();
    wxASSERT(m_fileId == 0);
}

bool asFileNetcdf::Open() {
    if (!Find()) return false;

    wxString datetime, generator;

    if (m_fileMode != ReadOnly) {
        datetime = asTime::GetStringTime(asTime::NowTimeStruct(asLOCAL), ISOdateTime);
        generator = _("Generated by AtmoSwing ") + g_version;
    }

    switch (m_fileMode) {
        case (ReadOnly): {
            m_defineMode = false;
            m_status = nc_open(m_fileName.GetFullPath().mb_str(wxConvUTF8), NC_NOWRITE, &m_fileId);
            if (m_status) HandleErrorNetcdf();
            m_opened = true;
            if (!ParseStruct()) {
                wxLogError(_("Failed parsing the file structure."));
                ClearStruct();
                return false;
            }
            break;
        }
        case (Write): {
            m_defineMode = true;
            m_status = nc_create(m_fileName.GetFullPath().mb_str(wxConvUTF8), NC_NETCDF4 | NC_WRITE, &m_fileId);
            if (m_status) HandleErrorNetcdf();
            m_opened = true;
            if (!ParseStruct()) {
                wxLogError(_("Failed parsing the file structure."));
                ClearStruct();
                return false;
            }
            break;
        }
        case (Replace): {
            m_defineMode = true;
            m_status = nc_create(m_fileName.GetFullPath().mb_str(wxConvUTF8), NC_NETCDF4 | NC_CLOBBER, &m_fileId);
            if (m_status) HandleErrorNetcdf();
            m_opened = true;
            PutAtt("creation_date", datetime);
            PutAtt("origin", generator);
            break;
        }
        case (New): {
            m_defineMode = true;
            m_status = nc_create(m_fileName.GetFullPath().mb_str(wxConvUTF8), NC_NETCDF4 | NC_NOCLOBBER, &m_fileId);
            if (m_status) HandleErrorNetcdf();
            m_opened = true;
            PutAtt("creation_date", datetime);
            PutAtt("origin", generator);
            break;
        }
        default: {
            throw runtime_error(_("No valid NetCdf FileMode has been selected"));
        }
    }

    m_opened = true;

    return true;
}

bool asFileNetcdf::Close() {
    // If not already closed
    if (m_fileId != 0) {
        CheckDefModeClosed();  // Check that the file is not in define mode
        ClearStruct();
        m_status = nc_close(m_fileId);
        if (m_status) HandleErrorNetcdf();
        m_fileId = 0;
    }

    return true;
}

bool asFileNetcdf::ForceClose() {
    CheckDefModeClosed();  // Check that the file is not in define mode
    ClearStruct();
    m_status = nc_close(m_fileId);
    m_fileId = 0;

    return true;
}

void asFileNetcdf::HandleErrorNetcdf() {
    if (m_status != NC_NOERR) {
        std::string tmpmessage = nc_strerror(m_status);
        wxString wxtmpmessage(tmpmessage.c_str(), wxConvUTF8);
        wxString errorMessage = asStrF(_("NetCDF error in file %s: %s"), m_fileName.GetName(), wxtmpmessage);
        throw runtime_error(errorMessage);
    }
}

void asFileNetcdf::DefDim(const wxString& dimName, const size_t& dimSize) {
    wxASSERT(m_opened);

    int dimId;

    // Check that the file is in define mode
    CheckDefModeOpen();

    if (dimSize == 0) {
        m_status = nc_def_dim(m_fileId, dimName.mb_str(wxConvUTF8), NC_UNLIMITED, &dimId);
        if (m_status) HandleErrorNetcdf();
        //        dimSize = 0;
    } else {
        m_status = nc_def_dim(m_fileId, dimName.mb_str(wxConvUTF8), dimSize, &dimId);
        if (m_status) HandleErrorNetcdf();
    }
}

void asFileNetcdf::DefVar(const wxString& varName, nc_type dataType, const int& varSize, const vstds& dimNames) {
    wxASSERT(m_opened);

    int varId, dimId, nDims;
    vi dimIds;

    // Check that the file is in define mode
    CheckDefModeOpen();

    nDims = (int)dimNames.size();

    for (int i = 0; i < nDims; i++) {
        m_status = nc_inq_dimid(m_fileId, dimNames[i].data(), &dimId);
        if (m_status) HandleErrorNetcdf();
        dimIds.push_back(dimId);
    }

    m_status = nc_def_var(m_fileId, varName.mb_str(wxConvUTF8), dataType, varSize, &dimIds[0], &varId);
    if (m_status) HandleErrorNetcdf();
}

void asFileNetcdf::DefVarDeflate(const wxString& varName, int shuffle, int deflateLevel) {
    wxASSERT(m_opened);

    int varId;

    m_status = nc_inq_varid(m_fileId, varName.mb_str(wxConvUTF8), &varId);
    if (m_status) HandleErrorNetcdf();

    m_status = nc_def_var_deflate(m_fileId, varId, shuffle, 1, deflateLevel);
    if (m_status) HandleErrorNetcdf();
}

void asFileNetcdf::PutAtt(const wxString& attName, const wxString& textStr, const wxString& varName) {
    wxASSERT(m_opened);

    int attId, varId;

    wxCharBuffer buffer = textStr.ToUTF8();

    // Check that the file is in define mode
    CheckDefModeOpen();

    // Check if global or not
    if ((varName.IsEmpty())) {
        m_status = nc_put_att_text(m_fileId, NC_GLOBAL, attName.mb_str(wxConvUTF8), strlen(buffer.data()),
                                   buffer.data());
        if (m_status) HandleErrorNetcdf();
        // Get the ID
        m_status = nc_inq_attid(m_fileId, NC_GLOBAL, attName.mb_str(wxConvUTF8), &attId);
        if (m_status) HandleErrorNetcdf();
    } else {
        m_status = nc_inq_varid(m_fileId, varName.mb_str(wxConvUTF8), &varId);
        if (m_status) HandleErrorNetcdf();
        m_status = nc_put_att_text(m_fileId, varId, attName.mb_str(wxConvUTF8), strlen(buffer.data()), buffer.data());
        if (m_status) HandleErrorNetcdf();
        // Get the ID
        m_status = nc_inq_attid(m_fileId, varId, attName.mb_str(wxConvUTF8), &attId);
        if (m_status) HandleErrorNetcdf();
    }
}

void asFileNetcdf::PutAtt(const wxString& attName, const short* attrValue, size_t length, const wxString& varName) {
    wxASSERT(m_opened);

    int attId, varId;

    // Check that the file is in define mode
    CheckDefModeOpen();

    // Check if global or not
    if (varName.IsEmpty()) {
        m_status = nc_put_att_short(m_fileId, NC_GLOBAL, attName.mb_str(wxConvUTF8), NC_SHORT, length, attrValue);
        if (m_status) HandleErrorNetcdf();
        // Get the ID
        m_status = nc_inq_attid(m_fileId, NC_GLOBAL, attName.mb_str(wxConvUTF8), &attId);
        if (m_status) HandleErrorNetcdf();
    } else {
        m_status = nc_inq_varid(m_fileId, varName.mb_str(wxConvUTF8), &varId);
        if (m_status) HandleErrorNetcdf();
        m_status = nc_put_att_short(m_fileId, varId, attName.mb_str(wxConvUTF8), NC_SHORT, length, attrValue);
        if (m_status) HandleErrorNetcdf();
        // Get the ID
        m_status = nc_inq_attid(m_fileId, varId, attName.mb_str(wxConvUTF8), &attId);
        if (m_status) HandleErrorNetcdf();
    }
}

void asFileNetcdf::PutAtt(const wxString& attName, const int* attrValue, size_t length, const wxString& varName) {
    wxASSERT(m_opened);

    int attId, varId;

    // Check that the file is in define mode
    CheckDefModeOpen();

    // Check if global or not
    if (varName.IsEmpty()) {
        m_status = nc_put_att_int(m_fileId, NC_GLOBAL, attName.mb_str(wxConvUTF8), NC_INT, length, attrValue);
        if (m_status) HandleErrorNetcdf();
        // Get the ID
        m_status = nc_inq_attid(m_fileId, NC_GLOBAL, attName.mb_str(wxConvUTF8), &attId);
        if (m_status) HandleErrorNetcdf();
    } else {
        m_status = nc_inq_varid(m_fileId, varName.mb_str(wxConvUTF8), &varId);
        if (m_status) HandleErrorNetcdf();
        m_status = nc_put_att_int(m_fileId, varId, attName.mb_str(wxConvUTF8), NC_INT, length, attrValue);
        if (m_status) HandleErrorNetcdf();
        // Get the ID
        m_status = nc_inq_attid(m_fileId, varId, attName.mb_str(wxConvUTF8), &attId);
        if (m_status) HandleErrorNetcdf();
    }
}

void asFileNetcdf::PutAtt(const wxString& attName, const float* attrValue, size_t length, const wxString& varName) {
    wxASSERT(m_opened);

    int attId, varId;

    // Check that the file is in define mode
    CheckDefModeOpen();

    // Check if global or not
    if (varName.IsEmpty()) {
        m_status = nc_put_att_float(m_fileId, NC_GLOBAL, attName.mb_str(wxConvUTF8), NC_FLOAT, length, attrValue);
        if (m_status) HandleErrorNetcdf();
        // Get the ID
        m_status = nc_inq_attid(m_fileId, NC_GLOBAL, attName.mb_str(wxConvUTF8), &attId);
        if (m_status) HandleErrorNetcdf();
    } else {
        m_status = nc_inq_varid(m_fileId, varName.mb_str(wxConvUTF8), &varId);
        if (m_status) HandleErrorNetcdf();
        m_status = nc_put_att_float(m_fileId, varId, attName.mb_str(wxConvUTF8), NC_FLOAT, length, attrValue);
        if (m_status) HandleErrorNetcdf();
        // Get the ID
        m_status = nc_inq_attid(m_fileId, varId, attName.mb_str(wxConvUTF8), &attId);
        if (m_status) HandleErrorNetcdf();
    }
}

void asFileNetcdf::PutAtt(const wxString& attName, const double* attrValue, size_t length, const wxString& varName) {
    wxASSERT(m_opened);

    int attId, varId;

    // Check that the file is in define mode
    CheckDefModeOpen();

    // Check if global or not
    if (varName.IsEmpty()) {
        m_status = nc_put_att_double(m_fileId, NC_GLOBAL, attName.mb_str(wxConvUTF8), NC_DOUBLE, length, attrValue);
        if (m_status) HandleErrorNetcdf();
        // Get the ID
        m_status = nc_inq_attid(m_fileId, NC_GLOBAL, attName.mb_str(wxConvUTF8), &attId);
        if (m_status) HandleErrorNetcdf();
    } else {
        m_status = nc_inq_varid(m_fileId, varName.mb_str(wxConvUTF8), &varId);
        if (m_status) HandleErrorNetcdf();
        m_status = nc_put_att_double(m_fileId, varId, attName.mb_str(wxConvUTF8), NC_DOUBLE, length, attrValue);
        if (m_status) HandleErrorNetcdf();
        // Get the ID
        m_status = nc_inq_attid(m_fileId, varId, attName.mb_str(wxConvUTF8), &attId);
        if (m_status) HandleErrorNetcdf();
    }
}

void asFileNetcdf::PutVarArray(const wxString& varName, const size_t* arrStart, const size_t* arrCount,
                               const short* pData) {
    wxASSERT(m_opened);

    int varId;

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get Var ID
    m_status = nc_inq_varid(m_fileId, varName.mb_str(wxConvUTF8), &varId);
    if (m_status) HandleErrorNetcdf();
    // Write data
    m_status = nc_put_vara_short(m_fileId, varId, arrStart, arrCount, pData);
    if (m_status) HandleErrorNetcdf();
}

void asFileNetcdf::PutVarArray(const wxString& varName, const size_t* arrStart, const size_t* arrCount,
                               const int* pData) {
    wxASSERT(m_opened);

    int varId;

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get Var ID
    m_status = nc_inq_varid(m_fileId, varName.mb_str(wxConvUTF8), &varId);
    if (m_status) HandleErrorNetcdf();
    // Write data
    m_status = nc_put_vara_int(m_fileId, varId, arrStart, arrCount, pData);
    if (m_status) HandleErrorNetcdf();
}

void asFileNetcdf::PutVarArray(const wxString& varName, const size_t* arrStart, const size_t* arrCount,
                               const float* pData) {
    wxASSERT(m_opened);

    int varId;

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get Var ID
    m_status = nc_inq_varid(m_fileId, varName.mb_str(wxConvUTF8), &varId);
    if (m_status) HandleErrorNetcdf();
    // Write data
    m_status = nc_put_vara_float(m_fileId, varId, arrStart, arrCount, pData);
    if (m_status) HandleErrorNetcdf();
}

void asFileNetcdf::PutVarArray(const wxString& varName, const size_t* arrStart, const size_t* arrCount,
                               const double* pData) {
    wxASSERT(m_opened);

    int varId;

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get Var ID
    m_status = nc_inq_varid(m_fileId, varName.mb_str(wxConvUTF8), &varId);
    if (m_status) HandleErrorNetcdf();
    // Write data
    m_status = nc_put_vara_double(m_fileId, varId, arrStart, arrCount, pData);
    if (m_status) HandleErrorNetcdf();
}

void asFileNetcdf::PutVarArray(const wxString& varName, const size_t* arrStart, const size_t* arrCount,
                               const void* pData) {
    wxASSERT(m_opened);

    int varId;

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get Var ID
    m_status = nc_inq_varid(m_fileId, varName.mb_str(wxConvUTF8), &varId);
    if (m_status) HandleErrorNetcdf();
    // Write data
    m_status = nc_put_vara(m_fileId, varId, arrStart, arrCount, pData);
    if (m_status) HandleErrorNetcdf();
}

void asFileNetcdf::PutVarArray(const wxString& varName, const size_t* arrStart, const size_t* arrCount,
                               const wxString* pData, const size_t totSize) {
    wxASSERT(m_opened);

    // From http://bytes.com/topic/c/answers/127614-best-way-copy-vector-string-char
    // Allocate memory for an array of character strings
    auto** cstr = new char*[totSize];

    // For each string, allocate memory in the character array and copy
    for (long i = 0; i < totSize; i++) {
        wxCharBuffer buffer = (pData + i)->ToUTF8();
        size_t length = strlen(buffer.data());
        cstr[i] = new char[length + 1];
        strncpy(cstr[i], buffer.data(), length);
        cstr[i][length] = '\0';
    }

    int varId;

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get Var ID
    m_status = nc_inq_varid(m_fileId, varName.mb_str(wxConvUTF8), &varId);
    if (m_status) HandleErrorNetcdf();
    // Write data
    m_status = nc_put_vara_string(m_fileId, varId, arrStart, arrCount, const_cast<const char**>(cstr));
    if (m_status) HandleErrorNetcdf();

    // Free dynamic memory
    for (long i = 0; i < totSize; i++) delete[] cstr[i];
    delete[] cstr;
}

void asFileNetcdf::CheckDefModeOpen() {
    wxASSERT(m_opened);

    if (!m_defineMode) {
        StartDef();
    }
}

void asFileNetcdf::CheckDefModeClosed() {
    if (m_defineMode) {
        EndDef();
    }
}

void asFileNetcdf::StartDef() {
    wxASSERT(m_opened);

    m_status = nc_redef(m_fileId);
    if (m_status) HandleErrorNetcdf();
    m_defineMode = false;
}

void asFileNetcdf::EndDef() {
    wxASSERT(m_opened);

    m_status = nc_enddef(m_fileId);
    if (m_status) HandleErrorNetcdf();
    m_defineMode = false;
    ParseStruct();
}

int asFileNetcdf::GetDimId(const wxString& dimName) {
    wxASSERT(m_opened);

    int id = asNOT_FOUND;

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get the variable id
    for (int iDim = 0; iDim < GetDimsNb(); iDim++) {
        if (m_struct.dims[iDim].name.IsSameAs(dimName)) {
            id = m_struct.dims[iDim].id;
        }
    }

    if (id == asNOT_FOUND) wxLogWarning(_("The desired variable doesn't exist: %s"), dimName);

    return id;
}

bool asFileNetcdf::HasVariable(const wxString& varName) {
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get the variable id
    for (int iVar = 0; iVar < GetVarsNb(); iVar++) {
        if (m_struct.vars[iVar].name.IsSameAs(varName)) {
            return true;
        }
    }

    return false;
}

int asFileNetcdf::GetVarId(const wxString& varName) {
    wxASSERT(m_opened);

    int id = asNOT_FOUND;

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get the variable id
    for (int iVar = 0; iVar < GetVarsNb(); iVar++) {
        if (m_struct.vars[iVar].name.IsSameAs(varName)) {
            id = m_struct.vars[iVar].id;
        }
    }

    if (id == asNOT_FOUND) wxLogWarning(_("The desired variable doesn't exist: %s"), varName);

    return id;
}

bool asFileNetcdf::HasAttribute(const wxString& attName, const wxString& varName) {
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get the attribute id
    if (varName.IsEmpty()) {  // Global attribute
        for (int iAtt = 0; iAtt < GetGlobAttsNb(); iAtt++) {
            if (m_struct.atts[iAtt].name.IsSameAs(attName)) {
                return true;
            }
        }
    } else {  // Variable attribute
        int varId = GetVarId(varName);
        if (varId == asNOT_FOUND) return false;
        for (int iAtt = 0; iAtt < GetVarAttsNb(varId); iAtt++) {
            if (m_struct.vars[varId].atts[iAtt].name.IsSameAs(attName)) {
                return true;
            }
        }
    }

    return false;
}

int asFileNetcdf::GetAttId(const wxString& attName, const wxString& varName) {
    wxASSERT(m_opened);

    int id = asNOT_FOUND;

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get the attribute id
    if (varName.IsEmpty()) {  // Global attribute
        for (int iAtt = 0; iAtt < GetGlobAttsNb(); iAtt++) {
            if (m_struct.atts[iAtt].name.IsSameAs(attName)) {
                id = m_struct.atts[iAtt].id;
            }
        }
    } else {  // Variable attribute
        int varId = GetVarId(varName);
        if (varId == asNOT_FOUND) return asNOT_FOUND;
        for (int iAtt = 0; iAtt < GetVarAttsNb(varId); iAtt++) {
            if (m_struct.vars[varId].atts[iAtt].name.IsSameAs(attName)) {
                id = m_struct.vars[varId].atts[iAtt].id;
            }
        }
    }

    if (id == asNOT_FOUND) {
        wxLogVerbose(_("The desired attribute doesn't exist: %s"), attName);
    }

    return id;
}

short asFileNetcdf::GetAttShort(const wxString& attName, const wxString& varName) {
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Check if global attribute or variable attribute
    if (varName.IsEmpty()) {  // Global attribute
        int attId = GetAttId(attName);
        if (attId == asNOT_FOUND) {
            throw runtime_error(_("Cannot find the desired attribute in the netCDF file."));
        }
        nc_type nctype = m_struct.atts[attId].type;

        // Check the given type
        if (nctype == NC_INT) {
            return (short)*static_cast<int*>(m_struct.atts[attId].pValue);
        } else if (nctype != NC_SHORT) {
            throw runtime_error(asStrF(_("The attribute (%s) type (%d) in file doesn't match the desired type (%d)."), attName,
                           (int)nctype, (int)NC_SHORT));
        }

        // Get value
        return *static_cast<short*>(m_struct.atts[attId].pValue);

    } else {  // Variable attribute
        int varId = GetVarId(varName);
        if (varId == asNOT_FOUND) {
            throw runtime_error(_("Cannot find the desired variable in the netCDF file."));
        }
        int attId = GetAttId(attName, varName);
        if (attId == asNOT_FOUND) {
            throw runtime_error(_("Cannot find the desired attribute in the netCDF file."));
        }
        nc_type nctype = m_struct.vars[varId].atts[attId].type;

        // Check the given type
        if (nctype == NC_INT) {
            return (short)*static_cast<int*>(m_struct.vars[varId].atts[attId].pValue);
        } else if (nctype != NC_SHORT) {
            throw runtime_error(asStrF(_("The attribute (%s.%s) type (%d) in file doesn't match the desired type (%d)."), varName,
                           attName, (int)nctype, (int)NC_SHORT));
        }

        // Get value
        return *static_cast<short*>(m_struct.vars[varId].atts[attId].pValue);
    }
}

int asFileNetcdf::GetAttInt(const wxString& attName, const wxString& varName) {
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Check if global attribute or variable attribute
    if (varName.IsEmpty()) {  // Global attribute
        int attId = GetAttId(attName);
        if (attId == asNOT_FOUND) return 0;
        nc_type nctype = m_struct.atts[attId].type;

        // Check the given type
        if (nctype == NC_SHORT) {
            return *static_cast<short*>(m_struct.atts[attId].pValue);
        } else if (nctype != NC_INT) {
            throw runtime_error(asStrF(_("The attribute (%s) type (%d) in file doesn't match the desired type (%d)."), attName,
                           (int)nctype, (int)NC_INT));
        }

        // Get value
        return *static_cast<int*>(m_struct.atts[attId].pValue);

    } else {  // Variable attribute
        int varId = GetVarId(varName);
        if (varId == asNOT_FOUND) return 0;
        int attId = GetAttId(attName, varName);
        if (attId == asNOT_FOUND) return 0;
        nc_type nctype = m_struct.vars[varId].atts[attId].type;

        // Check the given type
        if (nctype == NC_SHORT) {
            return *static_cast<short*>(m_struct.vars[varId].atts[attId].pValue);
        } else if (nctype != NC_INT) {
            throw runtime_error(asStrF(_("The attribute (%s.%s) type (%d) in file doesn't match the desired type (%d)."), varName,
                           attName, (int)nctype, (int)NC_INT));
        }

        // Get value
        return *static_cast<int*>(m_struct.vars[varId].atts[attId].pValue);
    }
}

float asFileNetcdf::GetAttFloat(const wxString& attName, const wxString& varName) {
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Check if global attribute or variable attribute
    if (varName.IsEmpty()) {  // Global attribute
        int attId = GetAttId(attName);
        if (attId == asNOT_FOUND) return NAN;
        nc_type nctype = m_struct.atts[attId].type;

        // Check the given type
        if (nctype == NC_DOUBLE) {
            return (float)*static_cast<double*>(m_struct.atts[attId].pValue);
        } else if (nctype != NC_FLOAT) {
            throw runtime_error(asStrF(_("The attribute (%s) type (%d) in file doesn't match the desired type (%d)."), attName,
                           (int)nctype, (int)NC_FLOAT));
        }

        // Get value
        return *static_cast<float*>(m_struct.atts[attId].pValue);

    } else {  // Variable attribute
        int varId = GetVarId(varName);
        if (varId == asNOT_FOUND) return NAN;
        int attId = GetAttId(attName, varName);
        if (attId == asNOT_FOUND) return NAN;
        nc_type nctype = m_struct.vars[varId].atts[attId].type;

        // Check the given type
        if (nctype == NC_DOUBLE) {
            return (float)*static_cast<double*>(m_struct.vars[varId].atts[attId].pValue);
        } else if (nctype != NC_FLOAT) {
            throw runtime_error(asStrF(_("The attribute (%s.%s) type (%d) in file doesn't match the desired type (%d)."), varName,
                           attName, (int)nctype, (int)NC_FLOAT));
        }

        // Get value
        return *static_cast<float*>(m_struct.vars[varId].atts[attId].pValue);
    }
}

double asFileNetcdf::GetAttDouble(const wxString& attName, const wxString& varName) {
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Check if global attribute or variable attribute
    if (varName.IsEmpty()) {  // Global attribute
        int attId = GetAttId(attName);
        if (attId == asNOT_FOUND) return NAN;
        nc_type nctype = m_struct.atts[attId].type;

        // Check the given type
        if (nctype == NC_FLOAT) {
            return (double)*static_cast<float*>(m_struct.atts[attId].pValue);
        } else if (nctype != NC_DOUBLE) {
            throw runtime_error(asStrF(_("The attribute (%s) type (%d) in file doesn't match the desired type (%d)."), attName,
                           (int)nctype, (int)NC_DOUBLE));
        }

        // Get value
        return *static_cast<double*>(m_struct.atts[attId].pValue);

    } else {  // Variable attribute
        int varId = GetVarId(varName);
        if (varId == asNOT_FOUND) return NAN;
        int attId = GetAttId(attName, varName);
        if (attId == asNOT_FOUND) return NAN;
        nc_type nctype = m_struct.vars[varId].atts[attId].type;

        // Check the given type
        if (nctype == NC_FLOAT) {
            return (double)*static_cast<float*>(m_struct.vars[varId].atts[attId].pValue);
        } else if (nctype != NC_DOUBLE) {
            throw runtime_error(asStrF(_("The attribute (%s.%s) type (%d) in file doesn't match the desired type (%d)."), varName,
                           attName, (int)nctype, (int)NC_DOUBLE));
        }

        // Get value
        return *static_cast<double*>(m_struct.vars[varId].atts[attId].pValue);
    }
}

char asFileNetcdf::GetAttChar(const wxString& attName, const wxString& varName) {
    wxASSERT(m_opened);

    char val;

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Check if global attribute or variable attribute
    if (varName.IsEmpty()) {  // Global attribute
        int attId = GetAttId(attName);
        if (attId == asNOT_FOUND) {
            throw runtime_error(_("Cannot find the desired attribute in the netCDF file."));
        }
        nc_type nctype = m_struct.atts[attId].type;

        // Check the given type
        if (nctype != NC_CHAR) {
            throw runtime_error(asStrF(_("The attribute (%s) type (%d) in file doesn't match the desired type (%d)."), attName,
                           (int)nctype, (int)NC_CHAR));
        }

        // Get value
        val = *static_cast<char*>(m_struct.atts[attId].pValue);

    } else {  // Variable attribute
        int varId = GetVarId(varName);
        if (varId == asNOT_FOUND) {
            throw runtime_error(_("Cannot find the desired variable in the netCDF file."));
        }
        int attId = GetAttId(attName, varName);
        if (attId == asNOT_FOUND) {
            throw runtime_error(_("Cannot find the desired attribute in the netCDF file."));
        }
        nc_type nctype = m_struct.vars[varId].atts[attId].type;

        // Check the given type
        if (nctype != NC_CHAR) {
            throw runtime_error(asStrF(_("The attribute (%s.%s) type (%d) in file doesn't match the desired type (%d)."), varName,
                           attName, (int)nctype, (int)NC_CHAR));
        }

        // Get value
        val = *static_cast<char*>(m_struct.vars[varId].atts[attId].pValue);
    }

    return val;
}

wxString asFileNetcdf::GetAttString(const wxString& attName, const wxString& varName) {
    wxASSERT(m_opened);

    size_t len;
    wxString attrValue;

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Check if global attribute or variable attribute
    if (varName.IsEmpty()) {  // Global attribute
        int attId = GetAttId(attName);
        if (attId == asNOT_FOUND) return wxEmptyString;

        // Allocate
        len = m_struct.atts[attId].length;
        auto* text = new char[len + 1]; /* + 1 for trailing null */

        // Check the given type
        nc_type nctype = m_struct.atts[attId].type;
        if (nctype != NC_CHAR) {
            wxDELETEA(text);
            throw runtime_error(asStrF(_("The attribute (%s) type (%d) in file doesn't match the desired type (%d)."), attName,
                           (int)nctype, (int)NC_CHAR));
        }

        // Get value
        m_status = nc_get_att_text(m_fileId, NC_GLOBAL, attName.mb_str(wxConvUTF8), text);
        if (m_status) HandleErrorNetcdf();

        text[len] = '\0';

        // Copy into a wxString
        attrValue = wxString(text, wxConvUTF8);
        wxASSERT(!attrValue.IsEmpty());
        attrValue.Remove(len);  // Remove the stuff after the end of the string
        wxASSERT(!attrValue.IsEmpty());
        wxDELETEA(text);

    } else {  // Variable attribute
        int varId = GetVarId(varName);
        if (varId == asNOT_FOUND) return wxEmptyString;
        int attId = GetAttId(attName, varName);
        if (attId == asNOT_FOUND) return wxEmptyString;

        // Allocate
        len = m_struct.vars[varId].atts[attId].length;
        auto* text = new char[len + 1]; /* + 1 for trailing null */

        // Check the given type
        nc_type nctype = m_struct.vars[varId].atts[attId].type;
        if (nctype != NC_CHAR) {
            wxDELETEA(text);
            throw runtime_error(asStrF(_("The attribute (%s.%s) type (%d) in file doesn't match the desired type (%d)."), varName,
                           attName, (int)nctype, (int)NC_CHAR));
        }

        // Get value
        m_status = nc_get_att_text(m_fileId, varId, attName.mb_str(wxConvUTF8), text);
        if (m_status) HandleErrorNetcdf();

        text[len] = '\0';

        // Copy into a wxString
        attrValue = wxString(text);
        wxASSERT(!attrValue.IsEmpty());
        attrValue.Remove(len);  // Remove the stuff after the end of the string
        wxASSERT(!attrValue.IsEmpty());
        wxDELETEA(text);
    }

    return attrValue;
}

size_t asFileNetcdf::GetDimLength(const wxString& dimName) {
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    int dimId = GetDimId(dimName);
    if (dimId == asNOT_FOUND) return 0;

    // Get the variable length
    return m_struct.dims[dimId].length;
}

size_t asFileNetcdf::GetVarLength(const wxString& varName) {
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    int varId = GetVarId(varName);
    if (varId == asNOT_FOUND) return 0;

    return m_struct.vars[varId].length;
}

nc_type asFileNetcdf::GetVarType(const wxString& varName) {
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    int varId = GetVarId(varName);
    if (varId == asNOT_FOUND) {
        throw runtime_error(_("Variable name not found in the file."));
    }

    return m_struct.vars[varId].type;
}

void asFileNetcdf::GetVar(const wxString& varName, short* pValue) {
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get the variable value
    int varId = GetVarId(varName);
    if (varId == asNOT_FOUND) {
        throw runtime_error(_("Cannot get the desired variable from the netCDF file."));
    }

    // Check the given type
    nc_type nctype = m_struct.vars[varId].type;
    if (nctype != NC_SHORT)
        throw runtime_error(asStrF(_("The variable (%s) type (%d) in file doesn't match the desired type (%d)."), varName,
                       (int)nctype, (int)NC_SHORT));

    // Get value
    m_status = nc_get_var_short(m_fileId, varId, pValue);
    if (m_status) HandleErrorNetcdf();
}

void asFileNetcdf::GetVar(const wxString& varName, int* pValue) {
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get the variable value
    int varId = GetVarId(varName);
    if (varId == asNOT_FOUND) {
        throw runtime_error(_("Cannot get the desired variable from the netCDF file."));
    }

    // Check the given type
    nc_type nctype = m_struct.vars[varId].type;
    if (nctype != NC_INT) {
        throw runtime_error(asStrF(_("The variable (%s) type (%d) in file doesn't match the desired type (%d)."), varName,
                       (int)nctype, (int)NC_INT));
    }

    // Get value
    m_status = nc_get_var_int(m_fileId, varId, pValue);
    if (m_status) HandleErrorNetcdf();
}

void asFileNetcdf::GetVar(const wxString& varName, float* pValue) {
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get the variable value
    int varId = GetVarId(varName);
    if (varId == asNOT_FOUND) {
        throw runtime_error(_("Cannot get the desired variable from the netCDF file."));
    }

    // Check the given type
    nc_type nctype = m_struct.vars[varId].type;
    if (nctype != NC_FLOAT) {
        throw runtime_error(asStrF(_("The variable (%s) type (%d) in file doesn't match the desired type (%d)."), varName,
                       (int)nctype, (int)NC_FLOAT));
    }

    // Get value
    m_status = nc_get_var_float(m_fileId, varId, pValue);
    if (m_status) HandleErrorNetcdf();
}

void asFileNetcdf::GetVar(const wxString& varName, double* pValue) {
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get the variable value
    int varId = GetVarId(varName);
    if (varId == asNOT_FOUND) {
        throw runtime_error(_("Cannot get the desired variable from the netCDF file."));
    }

    // Check the given type
    nc_type nctype = m_struct.vars[varId].type;
    if (nctype != NC_DOUBLE) {
        throw runtime_error(asStrF(_("The variable (%s) type (%d) in file doesn't match the desired type (%d)."), varName,
                       (int)nctype, (int)NC_DOUBLE));
    }

    // Get value
    m_status = nc_get_var_double(m_fileId, varId, pValue);
    if (m_status) HandleErrorNetcdf();
}

void asFileNetcdf::GetVar(const wxString& varName, wxString* pValue, const size_t totSize) {
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get the variable value
    int varId = GetVarId(varName);
    if (varId == asNOT_FOUND) {
        throw runtime_error(_("Cannot get the desired variable from the netCDF file."));
    }

    // Check the given type
    nc_type nctype = m_struct.vars[varId].type;
    if (nctype != NC_STRING) {
        throw runtime_error(asStrF(_("The variable (%s) type (%d) in file doesn't match the desired type (%d)."), varName,
                       (int)nctype, (int)NC_STRING));
    }

    // Get value
    vector<char*> data(totSize);
    m_status = nc_get_var_string(m_fileId, varId, &data[0]);
    if (m_status) HandleErrorNetcdf();

    // Set in the wxString array
    for (int i = 0; i < totSize; i++) {
        wxString val(data[i], wxConvUTF8);
        *(pValue + i) = val;
    }
}

short asFileNetcdf::GetVarOneShort(const wxString& varName, size_t arrIndex) {
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get the variable value
    int varId = GetVarId(varName);
    if (varId == asNOT_FOUND) {
        throw runtime_error(_("Cannot get the desired variable from the netCDF file."));
    }

    // Check the given type
    nc_type nctype = m_struct.vars[varId].type;
    if (nctype != NC_SHORT) {
        throw runtime_error(asStrF(_("The variable (%s) type (%d) in file doesn't match the desired type (%d)."), varName,
                       (int)nctype, (int)NC_SHORT));
    }

    // Get value
    short val;
    m_status = nc_get_var1_short(m_fileId, varId, &arrIndex, &val);
    if (m_status) HandleErrorNetcdf();

    return val;
}

int asFileNetcdf::GetVarOneInt(const wxString& varName, size_t arrIndex) {
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get the variable value
    int varId = GetVarId(varName);
    if (varId == asNOT_FOUND) {
        throw runtime_error(_("Cannot get the desired variable from the netCDF file."));
    }

    // Check the given type
    nc_type nctype = m_struct.vars[varId].type;
    if (nctype != NC_INT) {
        throw runtime_error(asStrF(_("The variable (%s) type (%d) in file doesn't match the desired type (%d)."), varName,
                       (int)nctype, (int)NC_INT));
    }

    // Get value
    int val;
    m_status = nc_get_var1_int(m_fileId, varId, &arrIndex, &val);
    if (m_status) HandleErrorNetcdf();

    return val;
}

float asFileNetcdf::GetVarOneFloat(const wxString& varName, size_t arrIndex) {
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get the variable value
    int varId = GetVarId(varName);
    if (varId == asNOT_FOUND) {
        throw runtime_error(_("Cannot get the desired variable from the netCDF file."));
    }

    // Check the given type
    nc_type nctype = m_struct.vars[varId].type;
    if (nctype != NC_FLOAT) {
        throw runtime_error(asStrF(_("The variable (%s) type (%d) in file doesn't match the desired type (%d)."), varName,
                       (int)nctype, (int)NC_FLOAT));
    }

    // Get value
    float val;
    m_status = nc_get_var1_float(m_fileId, varId, &arrIndex, &val);
    if (m_status) HandleErrorNetcdf();

    return val;
}

double asFileNetcdf::GetVarOneDouble(const wxString& varName, size_t arrIndex) {
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get the variable value
    int varId = GetVarId(varName);
    if (varId == asNOT_FOUND) {
        throw runtime_error(_("Cannot get the desired variable from the netCDF file."));
    }

    // Check the given type
    nc_type nctype = m_struct.vars[varId].type;
    if (nctype != NC_DOUBLE) {
        throw runtime_error(asStrF(_("The variable (%s) type (%d) in file doesn't match the desired type (%d)."), varName,
                       (int)nctype, (int)NC_DOUBLE));
    }

    // Get value
    double val;
    m_status = nc_get_var1_double(m_fileId, varId, &arrIndex, &val);
    if (m_status) HandleErrorNetcdf();

    return val;
}

void asFileNetcdf::GetVarArray(const wxString& varName, const size_t indexStart[], const size_t indexCount[],
                               short* pValue) {
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get the variable value
    int varId = GetVarId(varName);
    if (varId == asNOT_FOUND) {
        throw runtime_error(_("Cannot get the desired variable from the netCDF file."));
    }

    // Check the given type
    nc_type nctype = m_struct.vars[varId].type;
    if (nctype != NC_FLOAT && nctype != NC_SHORT && nctype != NC_DOUBLE && nctype != NC_INT && nctype != NC_INT64) {
        throw runtime_error(asStrF(_("The variable (%s) type (%d) in file doesn't match the desired type (numeric)."), varName,
                       (int)nctype));
    }

    // Get value
    m_status = nc_get_vara_short(m_fileId, varId, indexStart, indexCount, pValue);
    if (m_status) {
        wxString data = wxEmptyString;
        for (size_t i = 0; i < GetVarDimsNb(varId); i++) {
            data.Append(asStrF("indexStart[%d]=%d ", i, (int)indexStart[i]));
            data.Append(asStrF("indexCount[%d]=%d ", i, (int)indexCount[i]));
        }
        wxLogError(_("Requested indices: ") + data);
        HandleErrorNetcdf();
    }
}

void asFileNetcdf::GetVarArray(const wxString& varName, const size_t indexStart[], const size_t indexCount[],
                               int* pValue) {
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get the variable value
    int varId = GetVarId(varName);
    if (varId == asNOT_FOUND) {
        throw runtime_error(_("Cannot get the desired variable from the netCDF file."));
    }

    // Check the given type
    nc_type nctype = m_struct.vars[varId].type;
    if (nctype != NC_FLOAT && nctype != NC_SHORT && nctype != NC_DOUBLE && nctype != NC_INT && nctype != NC_INT64) {
        throw runtime_error(asStrF(_("The variable (%s) type (%d) in file doesn't match the desired type (numeric)."), varName,
                       (int)nctype));
    }

    // Get value
    m_status = nc_get_vara_int(m_fileId, varId, indexStart, indexCount, pValue);
    if (m_status) {
        wxString data = wxEmptyString;
        for (size_t i = 0; i < GetVarDimsNb(varId); i++) {
            data.Append(asStrF("indexStart[%d]=%d ", i, (int)indexStart[i]));
            data.Append(asStrF("indexCount[%d]=%d ", i, (int)indexCount[i]));
        }
        wxLogError(_("Requested indices: ") + data);
        HandleErrorNetcdf();
    }
}

void asFileNetcdf::GetVarArray(const wxString& varName, const size_t indexStart[], const size_t indexCount[],
                               float* pValue) {
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get the variable value
    int varId = GetVarId(varName);
    if (varId == asNOT_FOUND) {
        throw runtime_error(_("Cannot get the desired variable from the netCDF file."));
    }

    // Check the given type
    nc_type nctype = m_struct.vars[varId].type;
    if (nctype != NC_FLOAT && nctype != NC_SHORT && nctype != NC_DOUBLE && nctype != NC_INT && nctype != NC_INT64) {
        throw runtime_error(asStrF(_("The variable (%s) type (%d) in file doesn't match the desired type (numeric)."), varName,
                       (int)nctype));
    }

    // Get value
    m_status = nc_get_vara_float(m_fileId, varId, indexStart, indexCount, pValue);
    if (m_status) {
        wxString data = wxEmptyString;
        for (size_t i = 0; i < GetVarDimsNb(varId); i++) {
            data.Append(asStrF("indexStart[%d]=%d ", i, (int)indexStart[i]));
            data.Append(asStrF("indexCount[%d]=%d ", i, (int)indexCount[i]));
        }
        wxLogError(_("Requested indices: ") + data);
        HandleErrorNetcdf();
    }
}

void asFileNetcdf::GetVarArray(const wxString& varName, const size_t indexStart[], const size_t indexCount[],
                               double* pValue) {
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get the variable value
    int varId = GetVarId(varName);
    if (varId == asNOT_FOUND) {
        throw runtime_error(_("Cannot get the desired variable from the netCDF file."));
    }

    // Check the given type
    nc_type nctype = m_struct.vars[varId].type;
    if (nctype != NC_FLOAT && nctype != NC_SHORT && nctype != NC_DOUBLE && nctype != NC_INT && nctype != NC_INT64) {
        throw runtime_error(asStrF(_("The variable (%s) type (%d) in file doesn't match the desired type (numeric)."), varName,
                       (int)nctype));
    }

    // Get value
    m_status = nc_get_vara_double(m_fileId, varId, indexStart, indexCount, pValue);
    if (m_status) {
        wxString data = wxEmptyString;
        for (int i = 0; i < GetVarDimsNb(varId); i++) {
            data.Append(asStrF("indexStart[%d]=%d ", i, (int)indexStart[i]));
            data.Append(asStrF("indexCount[%d]=%d ", i, (int)indexCount[i]));
        }
        wxLogError(_("Requested indices: ") + data);
        HandleErrorNetcdf();
    }
}

void asFileNetcdf::GetVarSample(const wxString& varName, const size_t indexStart[], const size_t indexCount[],
                                const ptrdiff_t indexStride[], short* pValue) {
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get the variable value
    int varId = GetVarId(varName);
    if (varId == asNOT_FOUND) {
        throw runtime_error(_("Cannot get the desired variable from the netCDF file."));
    }

    // Check the given type
    nc_type nctype = m_struct.vars[varId].type;
    if (nctype != NC_FLOAT && nctype != NC_SHORT && nctype != NC_DOUBLE && nctype != NC_INT && nctype != NC_INT64) {
        throw runtime_error(asStrF(_("The variable (%s) type (%d) in file doesn't match the desired type (numeric)."), varName,
                       (int)nctype));
    }

    // Get value
    m_status = nc_get_vars_short(m_fileId, varId, indexStart, indexCount, indexStride, pValue);
    if (m_status) {
        wxString data = wxEmptyString;
        for (int i = 0; i < GetVarDimsNb(varId); i++) {
            data.Append(asStrF("indexStart[%d]=%d ", i, (int)indexStart[i]));
            data.Append(asStrF("indexCount[%d]=%d ", i, (int)indexCount[i]));
            data.Append(asStrF("indexStride[%d]=%d ", i, (int)indexStride[i]));
        }
        wxLogError(_("Requested indices: ") + data);
        HandleErrorNetcdf();
    }
}

void asFileNetcdf::GetVarSample(const wxString& varName, const size_t indexStart[], const size_t indexCount[],
                                const ptrdiff_t indexStride[], int* pValue) {
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get the variable value
    int varId = GetVarId(varName);
    if (varId == asNOT_FOUND) {
        throw runtime_error(_("Cannot get the desired variable from the netCDF file."));
    }

    // Check the given type
    nc_type nctype = m_struct.vars[varId].type;
    if (nctype != NC_FLOAT && nctype != NC_SHORT && nctype != NC_DOUBLE && nctype != NC_INT && nctype != NC_INT64) {
        throw runtime_error(asStrF(_("The variable (%s) type (%d) in file doesn't match the desired type (numeric)."), varName,
                       (int)nctype));
    }

    // Get value
    m_status = nc_get_vars_int(m_fileId, varId, indexStart, indexCount, indexStride, pValue);
    if (m_status) {
        wxString data = wxEmptyString;
        for (int i = 0; i < GetVarDimsNb(varId); i++) {
            data.Append(asStrF("indexStart[%d]=%d ", i, (int)indexStart[i]));
            data.Append(asStrF("indexCount[%d]=%d ", i, (int)indexCount[i]));
            data.Append(asStrF("indexStride[%d]=%d ", i, (int)indexStride[i]));
        }
        wxLogError(_("Requested indices: ") + data);
        HandleErrorNetcdf();
    }
}

void asFileNetcdf::GetVarSample(const wxString& varName, const size_t indexStart[], const size_t indexCount[],
                                const ptrdiff_t indexStride[], float* pValue) {
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get the variable value
    int varId = GetVarId(varName);
    if (varId == asNOT_FOUND) {
        throw runtime_error(_("Cannot get the desired variable from the netCDF file."));
    }

    // Check the given type. Allow the short type here.
    nc_type nctype = m_struct.vars[varId].type;
    if (nctype != NC_FLOAT && nctype != NC_SHORT && nctype != NC_DOUBLE && nctype != NC_INT && nctype != NC_INT64) {
        throw runtime_error(asStrF(_("The variable (%s) type (%d) in file doesn't match the desired type (numeric)."), varName,
                       (int)nctype));
    }

    // Get value
    m_status = nc_get_vars_float(m_fileId, varId, indexStart, indexCount, indexStride, pValue);
    if (m_status) {
        wxString data = wxEmptyString;
        for (int i = 0; i < GetVarDimsNb(varId); i++) {
            data.Append(asStrF("indexStart[%d]=%d ", i, (int)indexStart[i]));
            data.Append(asStrF("indexCount[%d]=%d ", i, (int)indexCount[i]));
            data.Append(asStrF("indexStride[%d]=%d ", i, (int)indexStride[i]));
        }
        wxLogError(_("Requested indices: ") + data);
        HandleErrorNetcdf();
    }
}

void asFileNetcdf::GetVarSample(const wxString& varName, const size_t indexStart[], const size_t indexCount[],
                                const ptrdiff_t indexStride[], double* pValue) {
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get the variable value
    int varId = GetVarId(varName);
    if (varId == asNOT_FOUND) {
        throw runtime_error(_("Cannot get the desired variable from the netCDF file."));
    }

    // Check the given type
    nc_type nctype = m_struct.vars[varId].type;
    if (nctype != NC_FLOAT && nctype != NC_SHORT && nctype != NC_DOUBLE && nctype != NC_INT && nctype != NC_INT64) {
        throw runtime_error(asStrF(_("The variable (%s) type (%d) in file doesn't match the desired type (numeric)."), varName,
                       (int)nctype));
    }

    // Get value
    m_status = nc_get_vars_double(m_fileId, varId, indexStart, indexCount, indexStride, pValue);
    if (m_status) {
        wxString data = wxEmptyString;
        for (int i = 0; i < GetVarDimsNb(varId); i++) {
            data.Append(asStrF("indexStart[%d]=%d ", i, (int)indexStart[i]));
            data.Append(asStrF("indexCount[%d]=%d ", i, (int)indexCount[i]));
            data.Append(asStrF("indexStride[%d]=%d ", i, (int)indexStride[i]));
        }
        wxLogError(_("Requested indices: ") + data);
        HandleErrorNetcdf();
    }
}

void asFileNetcdf::ClearStruct() {
    for (auto& var : m_struct.vars) {
        for (auto& att : var.atts) {
            if (att.pValue != nullptr) {
                nc_type nctype = att.type;

                // Cleanup from
                // http://stackoverflow.com/questions/206257/freeing-memory-allocated-to-an-array-of-void-pointers
                switch (nctype) {
                    case NC_CHAR:  // NC_CHAR - ISO/ASCII character
                    {
                        delete static_cast<char*>(att.pValue);
                        break;
                    }

                    case NC_SHORT:  // NC_SHORT - signed 2 byte integer
                    {
                        delete static_cast<short*>(att.pValue);
                        break;
                    }

                    case NC_INT:  // NC_INT - signed 4 byte integer
                    {
                        delete static_cast<int32_t*>(att.pValue);
                        break;
                    }

                    case NC_INT64:  // NC_INT64 - signed 8 byte integer
                    {
                        delete static_cast<int64_t*>(att.pValue);
                        break;
                    }

                    case NC_FLOAT:  // NC_FLOAT - single precision floating point number
                    {
                        delete static_cast<float*>(att.pValue);
                        break;
                    }

                    case NC_DOUBLE:  // NC_DOUBLE - double precision floating point number
                    {
                        delete static_cast<double*>(att.pValue);
                        break;
                    }

                    default:
                        throw runtime_error(asStrF(
                            _("NetCDF file: data type (%d) of attribute %s not taken into account in AtmoSwing."),
                            nctype, att.name));
                }

                att.pValue = nullptr;
            }
        }
    }

    for (auto& att : m_struct.atts) {
        if (att.pValue != nullptr) {
            nc_type nctype = att.type;

            switch (nctype) {
                case NC_CHAR:  // NC_CHAR - ISO/ASCII character
                {
                    delete static_cast<char*>(att.pValue);
                    break;
                }

                case NC_SHORT:  // NC_SHORT - signed 2 byte integer
                {
                    delete static_cast<short*>(att.pValue);
                    break;
                }

                case NC_INT:  // NC_INT - signed 4 byte integer
                {
                    delete static_cast<int32_t*>(att.pValue);
                    break;
                }

                case NC_INT64:  // NC_INT64 - signed 8 byte integer
                {
                    delete static_cast<int64_t*>(att.pValue);
                    break;
                }

                case NC_FLOAT:  // NC_FLOAT - single precision floating point number
                {
                    delete static_cast<float*>(att.pValue);
                    break;
                }

                case NC_DOUBLE:  // NC_DOUBLE - double precision floating point number
                {
                    delete static_cast<double*>(att.pValue);
                    break;
                }

                default:
                    throw runtime_error(
                        asStrF(_("NetCDF file: data type (%d) of attribute %s not taken into account in AtmoSwing."),
                               nctype, att.name));
            }

            att.pValue = nullptr;
        }
    }
}

bool asFileNetcdf::ParseStruct() {
    // Clear current structure
    ClearStruct();

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Inquire about the NetCDF Dataset
    int nDims, nVars, nAtts, uDimId;
    m_status = nc_inq(m_fileId, &nDims, &nVars, &nAtts, &uDimId);
    if (m_status) HandleErrorNetcdf();

    // Get the file format
    int format;
    m_status = nc_inq_format(m_fileId, &format);
    if (m_status) HandleErrorNetcdf();
    switch (format) {
        case (NC_FORMAT_CLASSIC):
            m_struct.format = Classic;
            break;
        case (NC_FORMAT_64BIT):
            m_struct.format = Format64bit;
            break;
        case (NC_FORMAT_NETCDF4):
            m_struct.format = Netcdf4;
            break;
        case (NC_FORMAT_NETCDF4_CLASSIC):
            m_struct.format = Netcdf4Classic;
            break;
        default:
            wxLogError(_("The NetCDF format is unknown"));
            return false;
    }

    // Inquire about the dimensions
    for (int dimId = 0; dimId < nDims; dimId++) {
        size_t length;
        char dimNameChar[NC_MAX_NAME + 1];
        m_status = nc_inq_dim(m_fileId, dimId, dimNameChar, &length);
        if (m_status) HandleErrorNetcdf();

        NcDimStruct nds = {dimId, wxString(dimNameChar, wxConvUTF8), length};

        m_struct.dims.push_back(nds);
    }

    // FIXME (phorton#1#): Cannot get the Netcdf4 functions ??
    // Find all unlimited dimensions
    int unlimDimIds[NC_MAX_DIMS];
    m_status = nc_inq_unlimdims(m_fileId, &m_struct.nUDims, nullptr);
    if (m_status) HandleErrorNetcdf();
    m_struct.uDimIds.resize(m_struct.nUDims);
    m_status = nc_inq_unlimdims(m_fileId, &m_struct.nUDims, unlimDimIds);
    if (m_status) HandleErrorNetcdf();
    for (int i = 0; i < m_struct.nUDims; i++) {
        m_struct.uDimIds[i] = unlimDimIds[i];
    }

    // Find 1 unlimited dimension
    m_struct.uDimIds.resize(1);
    m_status = nc_inq_unlimdim(m_fileId, unlimDimIds);
    if (m_status) HandleErrorNetcdf();
    m_struct.uDimIds[0] = unlimDimIds[0];

    // Resize array to store the global attributes
    m_struct.atts.resize((long)nAtts);

    // Get the global attributes
    for (int attId = 0; attId < nAtts; attId++) {
        // Get the attribute name
        char attNameChar[NC_MAX_NAME + 1];
        m_status = nc_inq_attname(m_fileId, NC_GLOBAL, attId, attNameChar);
        if (m_status) HandleErrorNetcdf();
        m_struct.atts[attId].id = attId;
        wxString tmpName(attNameChar, wxConvUTF8);
        m_struct.atts[attId].name = tmpName;

        // Get the attribute type and length
        m_status = nc_inq_att(m_fileId, NC_GLOBAL, attNameChar, &m_struct.atts[attId].type,
                              &m_struct.atts[attId].length);
        if (m_status) HandleErrorNetcdf();
        size_t len = m_struct.atts[attId].length;

        // Only store simple attributes
        if (len > 1) {
            m_struct.atts[attId].pValue = nullptr;
        } else {
            nc_type nctype = m_struct.atts[attId].type;

            switch (nctype) {
                case NC_CHAR:  // NC_CHAR - ISO/ASCII character
                {
                    m_struct.atts[attId].pValue = new char();
                    break;
                }

                case NC_SHORT:  // NC_SHORT - signed 2 byte integer
                {
                    m_struct.atts[attId].pValue = new short();
                    break;
                }

                case NC_INT:  // NC_INT - signed 4 byte integer
                {
                    m_struct.atts[attId].pValue = new int32_t();
                    break;
                }

                case NC_INT64:  // NC_INT64 - signed 8 byte integer
                {
                    m_struct.atts[attId].pValue = new int64_t();
                    break;
                }

                case NC_FLOAT:  // NC_FLOAT - single precision floating point number
                {
                    m_struct.atts[attId].pValue = new float();
                    break;
                }

                case NC_DOUBLE:  // NC_DOUBLE - double precision floating point number
                {
                    m_struct.atts[attId].pValue = new double();
                    break;
                }

                default:
                    wxLogError(_("NetCDF file: data type (%d) of attribute %s not taken into account in AtmoSwing."),
                               nctype, m_struct.atts[attId].name);
                    return false;
                    break;
            }

            // Get the attribute value
            m_status = nc_get_att(m_fileId, NC_GLOBAL, attNameChar, m_struct.atts[attId].pValue);
            if (m_status) HandleErrorNetcdf();
        }
    }

    // Resize arrays to store the variables information
    m_struct.vars.resize((long)nVars);

    // Get information about the variables and get limited variables (1D)
    for (int varId = 0; varId < nVars; varId++) {
        int nDimsVar, nAttsVar;
        char varNameChar[NC_MAX_NAME + 1];
        int dimIds[NC_MAX_VAR_DIMS];
        m_status = nc_inq_var(m_fileId, varId, varNameChar, &m_struct.vars[varId].type, &nDimsVar, dimIds, &nAttsVar);
        if (m_status) HandleErrorNetcdf();
        m_struct.vars[varId].id = varId;
        m_struct.vars[varId].name = wxString(varNameChar, wxConvUTF8);
        m_struct.vars[varId].length = 0;

        m_struct.vars[varId].dimIds.resize((long)nDimsVar);
        for (int j = 0; j < nDimsVar; j++) {
            m_struct.vars[varId].dimIds[j] = dimIds[j];
        }

        // Find the corresponding dimension to get its length
        for (auto& dim : m_struct.dims) {
            if (m_struct.vars[varId].name.IsSameAs(dim.name)) {
                m_struct.vars[varId].length = dim.length;
            }
        }

        // Resize array to store the attributes information
        m_struct.vars[varId].atts.resize((long)nAttsVar);

        // Get the attributes information
        for (int attId = 0; attId < nAttsVar; attId++) {
            // Get the attribute name
            char attNameChar[NC_MAX_NAME + 1];
            m_status = nc_inq_attname(m_fileId, varId, attId, attNameChar);
            if (m_status) HandleErrorNetcdf();
            m_struct.vars[varId].atts[attId].id = attId;
            m_struct.vars[varId].atts[attId].name = wxString(attNameChar, wxConvUTF8);

            // Get the attribute type and length
            m_status = nc_inq_att(m_fileId, varId, attNameChar, &m_struct.vars[varId].atts[attId].type,
                                  &m_struct.vars[varId].atts[attId].length);
            if (m_status) HandleErrorNetcdf();
            size_t len = m_struct.vars[varId].atts[attId].length;
            // Only store simple attributes
            if (len > 1) {
                m_struct.vars[varId].atts[attId].pValue = nullptr;
            } else {
                nc_type nctype = m_struct.vars[varId].atts[attId].type;

                switch (nctype) {
                    case NC_CHAR:  // NC_CHAR - ISO/ASCII character
                    {
                        m_struct.vars[varId].atts[attId].pValue = new char();
                        break;
                    }

                    case NC_SHORT:  // NC_SHORT - signed 2 byte integer
                    {
                        m_struct.vars[varId].atts[attId].pValue = new short();
                        break;
                    }

                    case NC_INT:  // NC_INT - signed 4 byte integer
                    {
                        m_struct.vars[varId].atts[attId].pValue = new int32_t();
                        break;
                    }

                    case NC_INT64:  // NC_INT64 - signed 8 byte integer
                    {
                        m_struct.vars[varId].atts[attId].pValue = new int64_t();
                        break;
                    }

                    case NC_FLOAT:  // NC_FLOAT - single precision floating point number
                    {
                        m_struct.vars[varId].atts[attId].pValue = new float();
                        break;
                    }

                    case NC_DOUBLE:  // NC_DOUBLE - double precision floating point number
                    {
                        m_struct.vars[varId].atts[attId].pValue = new double();
                        break;
                    }

                    default:
                        wxLogError(
                            _("NetCDF file: data type (%d) of attribute %s not taken into account in AtmoSwing."),
                            nctype, m_struct.vars[varId].atts[attId].name);
                        return false;
                        break;
                }

                // Get the attribute value
                m_status = nc_get_att(m_fileId, varId, attNameChar, m_struct.vars[varId].atts[attId].pValue);
                if (m_status) HandleErrorNetcdf();
            }
        }
    }

    return true;
}

size_t asFileNetcdf::GetVarLength(int& varId) const {
    wxASSERT(m_opened);

    // No previous checks necessary
    size_t len = 0;

    // Get the variable length
    len = m_struct.vars[varId].length;

    return len;
}
