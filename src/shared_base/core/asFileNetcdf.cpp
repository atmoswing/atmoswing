/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can read the License at http://opensource.org/licenses/CDDL-1.0
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL Header Notice in
 * each file and include the License file (licence.txt). If applicable,
 * add the following below this CDDL Header, with the fields enclosed
 * by brackets [] replaced by your own identifying information:
 * "Portions Copyright [year] [name of copyright owner]"
 *
 * The Original Software is AtmoSwing.
 * The Original Software was developed at the University of Lausanne.
 * All Rights Reserved.
 *
 */

/*
 * Portions Copyright 2008-2013 Pascal Horton, University of Lausanne.
 * Portions Copyright 2013-2015 Pascal Horton, Terranum.
 */

#include "asFileNetcdf.h"

#include <stdint.h> // To get  int32_t and int64_t

asFileNetcdf::asFileNetcdf(const wxString &fileName, const ListFileMode &fileMode)
        : asFile(fileName, fileMode)
{
    m_fileId = 0;
    m_status = 0;
    m_struct = NcStruct();
    m_struct.format = Classic;
    m_defineMode = false;
}

asFileNetcdf::~asFileNetcdf()
{
    // If file opened
    if (m_fileId != 0) {
        Close();
    }
}

bool asFileNetcdf::Open()
{
    if (!Find())
        return false;

    wxString datetime, generator;

    if (m_fileMode != ReadOnly) {
        datetime = asTime::GetStringTime(asTime::NowTimeStruct(asLOCAL), DDMMYYYYhhmmss);
        generator = _("Generated by AtmoSwing");
    }

    switch (m_fileMode) {
        case (ReadOnly): {
            m_defineMode = false;
            m_status = nc_open(m_fileName.GetFullPath().mb_str(wxConvUTF8), NC_NOWRITE, &m_fileId);
            if (m_status)
                HandleErrorNetcdf();
            m_opened = true;
            if (!ParseStruct()) {
                asLogError(_("Failed parsing the file structure."));
                ClearStruct();
                return false;
            }
            break;
        }
        case (Write): {
            m_defineMode = true;
            m_status = nc_create(m_fileName.GetFullPath().mb_str(wxConvUTF8), NC_NETCDF4 | NC_WRITE, &m_fileId);
            if (m_status)
                HandleErrorNetcdf();
            m_opened = true;
            if (!ParseStruct()) {
                asLogError(_("Failed parsing the file structure."));
                ClearStruct();
                return false;
            }
            PutAtt("edition_date", datetime);
            break;
        }
        case (Replace): {
            m_defineMode = true;
            m_status = nc_create(m_fileName.GetFullPath().mb_str(wxConvUTF8), NC_NETCDF4 | NC_CLOBBER, &m_fileId);
            if (m_status)
                HandleErrorNetcdf();
            m_opened = true;
            PutAtt("creation_date", datetime);
            PutAtt("edition_date", datetime);
            PutAtt("origin", generator);
            break;
        }
        case (New): {
            m_defineMode = true;
            m_status = nc_create(m_fileName.GetFullPath().mb_str(wxConvUTF8), NC_NETCDF4 | NC_NOCLOBBER, &m_fileId);
            if (m_status)
                HandleErrorNetcdf();
            m_opened = true;
            PutAtt("creation_date", datetime);
            PutAtt("edition_date", datetime);
            PutAtt("origin", generator);
            break;
        }
        default: {
            asThrowException(_("No valid NetCdf FileMode has been selected"));
        }
    }

    m_opened = true;

    return true;
}

bool asFileNetcdf::Close()
{
    // If not already closed
    if (m_fileId != 0) {
        CheckDefModeClosed(); // Check that the file is not in define mode
        ClearStruct();
        m_status = nc_close(m_fileId);
        if (m_status)
            HandleErrorNetcdf();
        m_fileId = 0;
    }

    return true;
}

void asFileNetcdf::HandleErrorNetcdf()
{
    if (m_status != NC_NOERR) {
        std::string tmpmessage = nc_strerror(m_status);
        wxString wxtmpmessage(tmpmessage.c_str(), wxConvUTF8);
        wxString errorMessage = wxString::Format(_("NetCDF error in file %s: %s"), m_fileName.GetName(), wxtmpmessage);
        asThrowException(errorMessage);
    }
}

void asFileNetcdf::DefDim(const wxString &dimName, const size_t &dimSize)
{
    wxASSERT(m_opened);

    int dimId;

    // Check that the file is in define mode
    CheckDefModeOpen();

    if (dimSize == 0) {
        m_status = nc_def_dim(m_fileId, dimName.mb_str(wxConvUTF8), NC_UNLIMITED, &dimId);
        if (m_status)
            HandleErrorNetcdf();
        //        dimSize = 0;
    } else {
        m_status = nc_def_dim(m_fileId, dimName.mb_str(wxConvUTF8), dimSize, &dimId);
        if (m_status)
            HandleErrorNetcdf();
    }
}

void asFileNetcdf::DefVar(const wxString &varName, nc_type dataType, const int &varSize,
                          const VectorStdString &dimNames)
{
    wxASSERT(m_opened);

    int varId, dimId, NDims;
    VectorInt dimIds;

    // Check that the file is in define mode
    CheckDefModeOpen();

    NDims = (int) dimNames.size();

    for (int i = 0; i < NDims; i++) {
        const char *dimNamesChar = dimNames[i].data();
        m_status = nc_inq_dimid(m_fileId, dimNamesChar, &dimId);
        if (m_status)
            HandleErrorNetcdf();
        dimIds.push_back(dimId);
    }

    m_status = nc_def_var(m_fileId, varName.mb_str(wxConvUTF8), dataType, varSize, &dimIds[0], &varId);
    if (m_status)
        HandleErrorNetcdf();
}

void asFileNetcdf::DefVarDeflate(const wxString &varName, int shuffle, int deflateLevel)
{
    wxASSERT(m_opened);

    int varId;

    m_status = nc_inq_varid(m_fileId, varName.mb_str(wxConvUTF8), &varId);
    if (m_status)
        HandleErrorNetcdf();

    m_status = nc_def_var_deflate(m_fileId, varId, shuffle, 1, deflateLevel);
    if (m_status)
        HandleErrorNetcdf();
}

void asFileNetcdf::PutAtt(const wxString &attName, const wxString &textStr, const wxString &varName)
{
    wxASSERT(m_opened);

    int attId, varId;

    wxCharBuffer buffer = textStr.ToUTF8();

    // Check that the file is in define mode
    CheckDefModeOpen();

    // Check if global or not
    if ((varName.IsEmpty())) {
        m_status = nc_put_att_text(m_fileId, NC_GLOBAL, attName.mb_str(wxConvUTF8), strlen(buffer.data()),
                                   buffer.data());
        if (m_status)
            HandleErrorNetcdf();
        // Get the ID
        m_status = nc_inq_attid(m_fileId, NC_GLOBAL, attName.mb_str(wxConvUTF8), &attId);
        if (m_status)
            HandleErrorNetcdf();
    } else {
        m_status = nc_inq_varid(m_fileId, varName.mb_str(wxConvUTF8), &varId);
        if (m_status)
            HandleErrorNetcdf();
        m_status = nc_put_att_text(m_fileId, varId, attName.mb_str(wxConvUTF8), strlen(buffer.data()), buffer.data());
        if (m_status)
            HandleErrorNetcdf();
        // Get the ID
        m_status = nc_inq_attid(m_fileId, varId, attName.mb_str(wxConvUTF8), &attId);
        if (m_status)
            HandleErrorNetcdf();
    }
}

void asFileNetcdf::PutAtt(const wxString &attName, const short *attrValue, size_t length, const wxString &varName)
{
    wxASSERT(m_opened);

    int attId, varId;

    // Check that the file is in define mode
    CheckDefModeOpen();

    // Check if global or not
    if (varName.IsEmpty()) {
        m_status = nc_put_att_short(m_fileId, NC_GLOBAL, attName.mb_str(wxConvUTF8), NC_SHORT, length, attrValue);
        if (m_status)
            HandleErrorNetcdf();
        // Get the ID
        m_status = nc_inq_attid(m_fileId, NC_GLOBAL, attName.mb_str(wxConvUTF8), &attId);
        if (m_status)
            HandleErrorNetcdf();
    } else {
        m_status = nc_inq_varid(m_fileId, varName.mb_str(wxConvUTF8), &varId);
        if (m_status)
            HandleErrorNetcdf();
        m_status = nc_put_att_short(m_fileId, varId, attName.mb_str(wxConvUTF8), NC_SHORT, length, attrValue);
        if (m_status)
            HandleErrorNetcdf();
        // Get the ID
        m_status = nc_inq_attid(m_fileId, varId, attName.mb_str(wxConvUTF8), &attId);
        if (m_status)
            HandleErrorNetcdf();
    }
}

void asFileNetcdf::PutAtt(const wxString &attName, const int *attrValue, size_t length, const wxString &varName)
{
    wxASSERT(m_opened);

    int attId, varId;

    // Check that the file is in define mode
    CheckDefModeOpen();

    // Check if global or not
    if (varName.IsEmpty()) {
        m_status = nc_put_att_int(m_fileId, NC_GLOBAL, attName.mb_str(wxConvUTF8), NC_INT, length, attrValue);
        if (m_status)
            HandleErrorNetcdf();
        // Get the ID
        m_status = nc_inq_attid(m_fileId, NC_GLOBAL, attName.mb_str(wxConvUTF8), &attId);
        if (m_status)
            HandleErrorNetcdf();
    } else {
        m_status = nc_inq_varid(m_fileId, varName.mb_str(wxConvUTF8), &varId);
        if (m_status)
            HandleErrorNetcdf();
        m_status = nc_put_att_int(m_fileId, varId, attName.mb_str(wxConvUTF8), NC_INT, length, attrValue);
        if (m_status)
            HandleErrorNetcdf();
        // Get the ID
        m_status = nc_inq_attid(m_fileId, varId, attName.mb_str(wxConvUTF8), &attId);
        if (m_status)
            HandleErrorNetcdf();
    }
}

void asFileNetcdf::PutAtt(const wxString &attName, const float *attrValue, size_t length, const wxString &varName)
{
    wxASSERT(m_opened);

    int attId, varId;

    // Check that the file is in define mode
    CheckDefModeOpen();

    // Check if global or not
    if (varName.IsEmpty()) {
        m_status = nc_put_att_float(m_fileId, NC_GLOBAL, attName.mb_str(wxConvUTF8), NC_FLOAT, length, attrValue);
        if (m_status)
            HandleErrorNetcdf();
        // Get the ID
        m_status = nc_inq_attid(m_fileId, NC_GLOBAL, attName.mb_str(wxConvUTF8), &attId);
        if (m_status)
            HandleErrorNetcdf();
    } else {
        m_status = nc_inq_varid(m_fileId, varName.mb_str(wxConvUTF8), &varId);
        if (m_status)
            HandleErrorNetcdf();
        m_status = nc_put_att_float(m_fileId, varId, attName.mb_str(wxConvUTF8), NC_FLOAT, length, attrValue);
        if (m_status)
            HandleErrorNetcdf();
        // Get the ID
        m_status = nc_inq_attid(m_fileId, varId, attName.mb_str(wxConvUTF8), &attId);
        if (m_status)
            HandleErrorNetcdf();
    }
}

void asFileNetcdf::PutAtt(const wxString &attName, const double *attrValue, size_t length, const wxString &varName)
{
    wxASSERT(m_opened);

    int attId, varId;

    // Check that the file is in define mode
    CheckDefModeOpen();

    // Check if global or not
    if (varName.IsEmpty()) {
        m_status = nc_put_att_double(m_fileId, NC_GLOBAL, attName.mb_str(wxConvUTF8), NC_DOUBLE, length, attrValue);
        if (m_status)
            HandleErrorNetcdf();
        // Get the ID
        m_status = nc_inq_attid(m_fileId, NC_GLOBAL, attName.mb_str(wxConvUTF8), &attId);
        if (m_status)
            HandleErrorNetcdf();
    } else {
        m_status = nc_inq_varid(m_fileId, varName.mb_str(wxConvUTF8), &varId);
        if (m_status)
            HandleErrorNetcdf();
        m_status = nc_put_att_double(m_fileId, varId, attName.mb_str(wxConvUTF8), NC_DOUBLE, length, attrValue);
        if (m_status)
            HandleErrorNetcdf();
        // Get the ID
        m_status = nc_inq_attid(m_fileId, varId, attName.mb_str(wxConvUTF8), &attId);
        if (m_status)
            HandleErrorNetcdf();
    }
}

void asFileNetcdf::PutVarArray(const wxString &varName, const size_t *arrStart, const size_t *arrCount,
                               const short *pData)
{
    wxASSERT(m_opened);

    int varId;

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get Var ID
    m_status = nc_inq_varid(m_fileId, varName.mb_str(wxConvUTF8), &varId);
    if (m_status)
        HandleErrorNetcdf();
    // Write data
    m_status = nc_put_vara_short(m_fileId, varId, arrStart, arrCount, pData);
    if (m_status)
        HandleErrorNetcdf();

}

void asFileNetcdf::PutVarArray(const wxString &varName, const size_t *arrStart, const size_t *arrCount,
                               const int *pData)
{
    wxASSERT(m_opened);

    int varId;

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get Var ID
    m_status = nc_inq_varid(m_fileId, varName.mb_str(wxConvUTF8), &varId);
    if (m_status)
        HandleErrorNetcdf();
    // Write data
    m_status = nc_put_vara_int(m_fileId, varId, arrStart, arrCount, pData);
    if (m_status)
        HandleErrorNetcdf();

}

void asFileNetcdf::PutVarArray(const wxString &varName, const size_t *arrStart, const size_t *arrCount,
                               const float *pData)
{
    wxASSERT(m_opened);

    int varId;

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get Var ID
    m_status = nc_inq_varid(m_fileId, varName.mb_str(wxConvUTF8), &varId);
    if (m_status)
        HandleErrorNetcdf();
    // Write data
    m_status = nc_put_vara_float(m_fileId, varId, arrStart, arrCount, pData);
    if (m_status)
        HandleErrorNetcdf();

}

void asFileNetcdf::PutVarArray(const wxString &varName, const size_t *arrStart, const size_t *arrCount,
                               const double *pData)
{
    wxASSERT(m_opened);

    int varId;

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get Var ID
    m_status = nc_inq_varid(m_fileId, varName.mb_str(wxConvUTF8), &varId);
    if (m_status)
        HandleErrorNetcdf();
    // Write data
    m_status = nc_put_vara_double(m_fileId, varId, arrStart, arrCount, pData);
    if (m_status)
        HandleErrorNetcdf();

}

void asFileNetcdf::PutVarArray(const wxString &varName, const size_t *arrStart, const size_t *arrCount,
                               const void *pData)
{
    wxASSERT(m_opened);

    int varId;

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get Var ID
    m_status = nc_inq_varid(m_fileId, varName.mb_str(wxConvUTF8), &varId);
    if (m_status)
        HandleErrorNetcdf();
    // Write data
    m_status = nc_put_vara(m_fileId, varId, arrStart, arrCount, pData);
    if (m_status)
        HandleErrorNetcdf();

}

void asFileNetcdf::PutVarArray(const wxString &varName, const size_t *arrStart, const size_t *arrCount,
                               const wxString *pData, const size_t totSize)
{
    wxASSERT(m_opened);

    // From http://bytes.com/topic/c/answers/127614-best-way-copy-vector-string-char
    // Allocate memory for an array of character strings
    char **cstr = new char *[totSize];

    // For each string, allocate memory in the character array and copy
    for (unsigned long i = 0; i < totSize; i++) {
        wxCharBuffer buffer = (pData + i)->ToUTF8();
        size_t length = strlen(buffer.data());
        cstr[i] = new char[length + 1];
        strncpy(cstr[i], buffer.data(), length);
        cstr[i][length] = '\0';
    }

    int varId;

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get Var ID
    m_status = nc_inq_varid(m_fileId, varName.mb_str(wxConvUTF8), &varId);
    if (m_status)
        HandleErrorNetcdf();
    // Write data
    m_status = nc_put_vara_string(m_fileId, varId, arrStart, arrCount, (const char **) cstr);
    if (m_status)
        HandleErrorNetcdf();

    // Free dynamic memory
    for (unsigned long i = 0; i < totSize; i++)
        delete[] cstr[i];
    delete[] cstr;

}

void asFileNetcdf::CheckDefModeOpen()
{
    wxASSERT(m_opened);

    if (!m_defineMode) {
        StartDef();
    }
}

void asFileNetcdf::CheckDefModeClosed()
{
    if (m_defineMode) {
        EndDef();
    }
}

void asFileNetcdf::StartDef()
{
    wxASSERT(m_opened);

    m_status = nc_redef(m_fileId);
    if (m_status)
        HandleErrorNetcdf();
    m_defineMode = false;
}

void asFileNetcdf::EndDef()
{
    wxASSERT(m_opened);

    m_status = nc_enddef(m_fileId);
    if (m_status)
        HandleErrorNetcdf();
    m_defineMode = false;
    ParseStruct();
}

int asFileNetcdf::GetDimId(const wxString &dimName)
{
    wxASSERT(m_opened);

    int id = asNOT_FOUND;

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get the variable id
    for (int i_dim = 0; i_dim < GetDimsNb(); i_dim++) {
        if (m_struct.dims[i_dim].name.IsSameAs(dimName)) {
            id = m_struct.dims[i_dim].id;
        }
    }

    if (id == asNOT_FOUND)
        asLogWarning(wxString::Format(_("The desired variable doesn't exist: %s"), dimName));

    return id;
}

int asFileNetcdf::GetVarId(const wxString &varName)
{
    wxASSERT(m_opened);

    int id = asNOT_FOUND;

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get the variable id
    for (int i_var = 0; i_var < GetVarsNb(); i_var++) {
        if (m_struct.vars[i_var].name.IsSameAs(varName)) {
            id = m_struct.vars[i_var].id;
        }
    }

    if (id == asNOT_FOUND)
        asLogWarning(wxString::Format(_("The desired variable doesn't exist: %s"), varName));

    return id;
}

int asFileNetcdf::GetAttId(const wxString &attName, const wxString &varName)
{
    wxASSERT(m_opened);

    int id = asNOT_FOUND;

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get the attribute id
    if (varName.IsEmpty()) { // Global attribute
        for (int i_att = 0; i_att < GetGlobAttsNb(); i_att++) {
            if (m_struct.atts[i_att].name.IsSameAs(attName)) {
                id = m_struct.atts[i_att].id;
            }
        }
    } else { // Variable attribute
        int varId = GetVarId(varName);
        if (varId == asNOT_FOUND)
            return asNOT_FOUND;
        for (int i_att = 0; i_att < GetVarAttsNb(varId); i_att++) {
            if (m_struct.vars[varId].atts[i_att].name.IsSameAs(attName)) {
                id = m_struct.vars[varId].atts[i_att].id;
            }
        }
    }

    if (id == asNOT_FOUND)
        asLogError(wxString::Format(_("The desired attribute doesn't exist: %s"), attName));

    return id;
}

short asFileNetcdf::GetAttShort(const wxString &attName, const wxString &varName)
{
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Check if global attribute or variable attribute
    if (varName.IsEmpty()) { // Global attribute
        int attId = GetAttId(attName);
        if (attId == asNOT_FOUND)
            asThrowException(_("Cannot find the desired attribute in the netCDF file."));
        nc_type nctype = m_struct.atts[attId].type;

        // Check the given type
        if (nctype == NC_INT) {
            return (short) *(int *) m_struct.atts[attId].pValue;
        } else if (nctype != NC_SHORT) {
            asThrowException(
                    wxString::Format(_("The attribute (%s) type (%d) in file doesn't match the desired type (%d)."),
                                     attName, (int) nctype, (int) NC_SHORT));
        }

        // Get value
        return *(short *) m_struct.atts[attId].pValue;

    } else { // Variable attribute
        int varId = GetVarId(varName);
        if (varId == asNOT_FOUND)
            asThrowException(_("Cannot find the desired variable in the netCDF file."));
        int attId = GetAttId(attName, varName);
        if (attId == asNOT_FOUND)
            asThrowException(_("Cannot find the desired attribute in the netCDF file."));
        nc_type nctype = m_struct.vars[varId].atts[attId].type;

        // Check the given type
        if (nctype == NC_INT) {
            return (short) *(int *) m_struct.vars[varId].atts[attId].pValue;
        } else if (nctype != NC_SHORT) {
            asThrowException(
                    wxString::Format(_("The attribute (%s.%s) type (%d) in file doesn't match the desired type (%d)."),
                                     varName, attName, (int) nctype, (int) NC_SHORT));
        }

        // Get value
        return *(short *) m_struct.vars[varId].atts[attId].pValue;
    }

}

int asFileNetcdf::GetAttInt(const wxString &attName, const wxString &varName)
{
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Check if global attribute or variable attribute
    if (varName.IsEmpty()) { // Global attribute
        int attId = GetAttId(attName);
        if (attId == asNOT_FOUND)
            return NaNInt;
        nc_type nctype = m_struct.atts[attId].type;

        // Check the given type
        if (nctype == NC_SHORT) {
            return (int) *(short *) m_struct.atts[attId].pValue;
        } else if (nctype != NC_INT) {
            asThrowException(
                    wxString::Format(_("The attribute (%s) type (%d) in file doesn't match the desired type (%d)."),
                                     attName, (int) nctype, (int) NC_INT));
        }

        // Get value
        return *(int *) m_struct.atts[attId].pValue;

    } else { // Variable attribute
        int varId = GetVarId(varName);
        if (varId == asNOT_FOUND)
            return NaNInt;
        int attId = GetAttId(attName, varName);
        if (attId == asNOT_FOUND)
            return NaNInt;
        nc_type nctype = m_struct.vars[varId].atts[attId].type;

        // Check the given type
        if (nctype == NC_SHORT) {
            return (int) *(short *) m_struct.vars[varId].atts[attId].pValue;
        } else if (nctype != NC_INT) {
            asThrowException(
                    wxString::Format(_("The attribute (%s.%s) type (%d) in file doesn't match the desired type (%d)."),
                                     varName, attName, (int) nctype, (int) NC_INT));
        }

        // Get value
        return *(int *) m_struct.vars[varId].atts[attId].pValue;
    }

}

float asFileNetcdf::GetAttFloat(const wxString &attName, const wxString &varName)
{
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Check if global attribute or variable attribute
    if (varName.IsEmpty()) { // Global attribute
        int attId = GetAttId(attName);
        if (attId == asNOT_FOUND)
            return NaNFloat;
        nc_type nctype = m_struct.atts[attId].type;

        // Check the given type
        if (nctype == NC_DOUBLE) {
            return (float) *(double *) m_struct.atts[attId].pValue;
        } else if (nctype != NC_FLOAT) {
            asThrowException(
                    wxString::Format(_("The attribute (%s) type (%d) in file doesn't match the desired type (%d)."),
                                     attName, (int) nctype, (int) NC_FLOAT));
        }

        // Get value
        return *(float *) m_struct.atts[attId].pValue;

    } else { // Variable attribute
        int varId = GetVarId(varName);
        if (varId == asNOT_FOUND)
            return NaNFloat;
        int attId = GetAttId(attName, varName);
        if (attId == asNOT_FOUND)
            return NaNFloat;
        nc_type nctype = m_struct.vars[varId].atts[attId].type;

        // Check the given type
        if (nctype == NC_DOUBLE) {
            return (float) *(double *) m_struct.vars[varId].atts[attId].pValue;
        } else if (nctype != NC_FLOAT) {
            asThrowException(
                    wxString::Format(_("The attribute (%s.%s) type (%d) in file doesn't match the desired type (%d)."),
                                     varName, attName, (int) nctype, (int) NC_FLOAT));
        }

        // Get value
        return *(float *) m_struct.vars[varId].atts[attId].pValue;
    }

}

double asFileNetcdf::GetAttDouble(const wxString &attName, const wxString &varName)
{
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Check if global attribute or variable attribute
    if (varName.IsEmpty()) { // Global attribute
        int attId = GetAttId(attName);
        if (attId == asNOT_FOUND)
            return NaNDouble;
        nc_type nctype = m_struct.atts[attId].type;

        // Check the given type
        if (nctype == NC_FLOAT) {
            return (double) *(float *) m_struct.atts[attId].pValue;
        } else if (nctype != NC_DOUBLE) {
            asThrowException(
                    wxString::Format(_("The attribute (%s) type (%d) in file doesn't match the desired type (%d)."),
                                     attName, (int) nctype, (int) NC_DOUBLE));
        }

        // Get value
        return *(double *) m_struct.atts[attId].pValue;

    } else { // Variable attribute
        int varId = GetVarId(varName);
        if (varId == asNOT_FOUND)
            return NaNDouble;
        int attId = GetAttId(attName, varName);
        if (attId == asNOT_FOUND)
            return NaNDouble;
        nc_type nctype = m_struct.vars[varId].atts[attId].type;

        // Check the given type
        if (nctype == NC_FLOAT) {
            return (double) *(float *) m_struct.vars[varId].atts[attId].pValue;
        } else if (nctype != NC_DOUBLE) {
            asThrowException(
                    wxString::Format(_("The attribute (%s.%s) type (%d) in file doesn't match the desired type (%d)."),
                                     varName, attName, (int) nctype, (int) NC_DOUBLE));
        }

        // Get value
        return *(double *) m_struct.vars[varId].atts[attId].pValue;
    }

}

char asFileNetcdf::GetAttChar(const wxString &attName, const wxString &varName)
{
    wxASSERT(m_opened);

    char val;

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Check if global attribute or variable attribute
    if (varName.IsEmpty()) { // Global attribute
        int attId = GetAttId(attName);
        if (attId == asNOT_FOUND)
            asThrowException(_("Cannot find the desired attribute in the netCDF file."));
        nc_type nctype = m_struct.atts[attId].type;

        // Check the given type
        if (nctype != NC_CHAR)
            asThrowException(
                    wxString::Format(_("The attribute (%s) type (%d) in file doesn't match the desired type (%d)."),
                                     attName, (int) nctype, (int) NC_CHAR));

        // Get value
        val = *(char *) m_struct.atts[attId].pValue;

    } else { // Variable attribute
        int varId = GetVarId(varName);
        if (varId == asNOT_FOUND)
            asThrowException(_("Cannot find the desired variable in the netCDF file."));
        int attId = GetAttId(attName, varName);
        if (attId == asNOT_FOUND)
            asThrowException(_("Cannot find the desired attribute in the netCDF file."));
        nc_type nctype = m_struct.vars[varId].atts[attId].type;

        // Check the given type
        if (nctype != NC_CHAR)
            asThrowException(
                    wxString::Format(_("The attribute (%s.%s) type (%d) in file doesn't match the desired type (%d)."),
                                     varName, attName, (int) nctype, (int) NC_CHAR));

        // Get value
        val = *(char *) m_struct.vars[varId].atts[attId].pValue;
    }

    return val;
}

wxString asFileNetcdf::GetAttString(const wxString &attName, const wxString &varName)
{
    wxASSERT(m_opened);

    size_t len;
    wxString attrValue;

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Check if global attribute or variable attribute
    if (varName.IsEmpty()) { // Global attribute
        int attId = GetAttId(attName);
        if (attId == asNOT_FOUND)
            return wxEmptyString;

        // Allocate
        len = m_struct.atts[attId].length;
        char *text = new char[len + 1]; /* + 1 for trailing null */

        // Check the given type
        nc_type nctype = m_struct.atts[attId].type;
        if (nctype != NC_CHAR) {
            wxDELETE(text);
            asThrowException(
                    wxString::Format(_("The attribute (%s) type (%d) in file doesn't match the desired type (%d)."),
                                     attName, (int) nctype, (int) NC_CHAR));
        }

        // Get value
        m_status = nc_get_att_text(m_fileId, NC_GLOBAL, attName.mb_str(wxConvUTF8), text);
        if (m_status)
            HandleErrorNetcdf();

        text[len] = '\0';

        // Copy into a wxString
        attrValue = wxString(text, wxConvUTF8);
        wxASSERT(!attrValue.IsEmpty());
        attrValue.Remove(len); // Remove the stuff after the end of the string
        wxASSERT(!attrValue.IsEmpty());
        wxDELETE(text);

    } else { // Variable attribute
        int varId = GetVarId(varName);
        if (varId == asNOT_FOUND)
            return wxEmptyString;
        int attId = GetAttId(attName, varName);
        if (attId == asNOT_FOUND)
            return wxEmptyString;

        // Allocate
        len = m_struct.vars[varId].atts[attId].length;
        char *text = new char[len + 1]; /* + 1 for trailing null */

        // Check the given type
        nc_type nctype = m_struct.vars[varId].atts[attId].type;
        if (nctype != NC_CHAR) {
            wxDELETE(text);
            asThrowException(
                    wxString::Format(_("The attribute (%s.%s) type (%d) in file doesn't match the desired type (%d)."),
                                     varName, attName, (int) nctype, (int) NC_CHAR));
        }

        // Get value
        m_status = nc_get_att_text(m_fileId, varId, attName.mb_str(wxConvUTF8), text);
        if (m_status)
            HandleErrorNetcdf();

        text[len] = '\0';

        // Copy into a wxString
        attrValue = wxString(text);
        wxASSERT(!attrValue.IsEmpty());
        attrValue.Remove(len); // Remove the stuff after the end of the string
        wxASSERT(!attrValue.IsEmpty());
        wxDELETE(text);
    }

    return attrValue;
}

size_t asFileNetcdf::GetDimLength(const wxString &dimName)
{
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    int dimId = GetDimId(dimName);
    if (dimId == asNOT_FOUND)
        return 0;

    // Get the variable length
    return m_struct.dims[dimId].length;
}

size_t asFileNetcdf::GetVarLength(const wxString &varName)
{
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    int varId = GetVarId(varName);
    if (varId == asNOT_FOUND)
        return 0;

    return m_struct.vars[varId].length;
}

nc_type asFileNetcdf::GetVarType(const wxString &varName)
{
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    int varId = GetVarId(varName);
    if (varId == asNOT_FOUND)
        asThrowException(_("Variable name not found in the file."));

    return m_struct.vars[varId].type;
}

void asFileNetcdf::GetVar(const wxString &varName, short *pValue)
{
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get the variable value
    int varId = GetVarId(varName);
    if (varId == asNOT_FOUND)
        asThrowException(_("Cannot get the desired variable from the netCDF file."));

    // Check the given type
    nc_type nctype = m_struct.vars[varId].type;
    if (nctype != NC_SHORT)
        asThrowException(
                wxString::Format(_("The variable (%s) type (%d) in file doesn't match the desired type (%d)."), varName,
                                 (int) nctype, (int) NC_SHORT));

    // Get value
    m_status = nc_get_var_short(m_fileId, varId, pValue);
    if (m_status)
        HandleErrorNetcdf();
}

void asFileNetcdf::GetVar(const wxString &varName, int *pValue)
{
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get the variable value
    int varId = GetVarId(varName);
    if (varId == asNOT_FOUND)
        asThrowException(_("Cannot get the desired variable from the netCDF file."));

    // Check the given type
    nc_type nctype = m_struct.vars[varId].type;
    if (nctype != NC_INT)
        asThrowException(
                wxString::Format(_("The variable (%s) type (%d) in file doesn't match the desired type (%d)."), varName,
                                 (int) nctype, (int) NC_INT));

    // Get value
    m_status = nc_get_var_int(m_fileId, varId, pValue);
    if (m_status)
        HandleErrorNetcdf();
}

void asFileNetcdf::GetVar(const wxString &varName, float *pValue)
{
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get the variable value
    int varId = GetVarId(varName);
    if (varId == asNOT_FOUND)
        asThrowException(_("Cannot get the desired variable from the netCDF file."));

    // Check the given type
    nc_type nctype = m_struct.vars[varId].type;
    if (nctype != NC_FLOAT)
        asThrowException(
                wxString::Format(_("The variable (%s) type (%d) in file doesn't match the desired type (%d)."), varName,
                                 (int) nctype, (int) NC_FLOAT));

    // Get value
    m_status = nc_get_var_float(m_fileId, varId, pValue);
    if (m_status)
        HandleErrorNetcdf();
}

void asFileNetcdf::GetVar(const wxString &varName, double *pValue)
{
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get the variable value
    int varId = GetVarId(varName);
    if (varId == asNOT_FOUND)
        asThrowException(_("Cannot get the desired variable from the netCDF file."));

    // Check the given type
    nc_type nctype = m_struct.vars[varId].type;
    if (nctype != NC_DOUBLE)
        asThrowException(
                wxString::Format(_("The variable (%s) type (%d) in file doesn't match the desired type (%d)."), varName,
                                 (int) nctype, (int) NC_DOUBLE));

    // Get value
    m_status = nc_get_var_double(m_fileId, varId, pValue);
    if (m_status)
        HandleErrorNetcdf();
}

void asFileNetcdf::GetVar(const wxString &varName, wxString *pValue, const size_t totSize)
{
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get the variable value
    int varId = GetVarId(varName);
    if (varId == asNOT_FOUND)
        asThrowException(_("Cannot get the desired variable from the netCDF file."));

    // Check the given type
    nc_type nctype = m_struct.vars[varId].type;
    if (nctype != NC_STRING)
        asThrowException(
                wxString::Format(_("The variable (%s) type (%d) in file doesn't match the desired type (%d)."), varName,
                                 (int) nctype, (int) NC_STRING));

    // Get value
    std::vector<char *> data(totSize);
    m_status = nc_get_var_string(m_fileId, varId, &data[0]);
    if (m_status)
        HandleErrorNetcdf();

    // Set in the wxString array
    for (unsigned int i = 0; i < totSize; i++) {
        wxString val(data[i], wxConvUTF8);
        *(pValue + i) = val;
    }

}

short asFileNetcdf::GetVarOneShort(const wxString &varName, size_t arrIndex)
{
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get the variable value
    int varId = GetVarId(varName);
    if (varId == asNOT_FOUND)
        asThrowException(_("Cannot get the desired variable from the netCDF file."));

    // Check the given type
    nc_type nctype = m_struct.vars[varId].type;
    if (nctype != NC_SHORT)
        asThrowException(
                wxString::Format(_("The variable (%s) type (%d) in file doesn't match the desired type (%d)."), varName,
                                 (int) nctype, (int) NC_SHORT));

    // Get value
    short val;
    m_status = nc_get_var1_short(m_fileId, varId, &arrIndex, &val);
    if (m_status)
        HandleErrorNetcdf();

    return val;
}

int asFileNetcdf::GetVarOneInt(const wxString &varName, size_t arrIndex)
{
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get the variable value
    int varId = GetVarId(varName);
    if (varId == asNOT_FOUND)
        asThrowException(_("Cannot get the desired variable from the netCDF file."));

    // Check the given type
    nc_type nctype = m_struct.vars[varId].type;
    if (nctype != NC_INT)
        asThrowException(
                wxString::Format(_("The variable (%s) type (%d) in file doesn't match the desired type (%d)."), varName,
                                 (int) nctype, (int) NC_INT));

    // Get value
    int val;
    m_status = nc_get_var1_int(m_fileId, varId, &arrIndex, &val);
    if (m_status)
        HandleErrorNetcdf();

    return val;
}

float asFileNetcdf::GetVarOneFloat(const wxString &varName, size_t arrIndex)
{
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get the variable value
    int varId = GetVarId(varName);
    if (varId == asNOT_FOUND)
        asThrowException(_("Cannot get the desired variable from the netCDF file."));

    // Check the given type
    nc_type nctype = m_struct.vars[varId].type;
    if (nctype != NC_FLOAT)
        asThrowException(
                wxString::Format(_("The variable (%s) type (%d) in file doesn't match the desired type (%d)."), varName,
                                 (int) nctype, (int) NC_FLOAT));

    // Get value
    float val;
    m_status = nc_get_var1_float(m_fileId, varId, &arrIndex, &val);
    if (m_status)
        HandleErrorNetcdf();

    return val;
}

double asFileNetcdf::GetVarOneDouble(const wxString &varName, size_t arrIndex)
{
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get the variable value
    int varId = GetVarId(varName);
    if (varId == asNOT_FOUND)
        asThrowException(_("Cannot get the desired variable from the netCDF file."));

    // Check the given type
    nc_type nctype = m_struct.vars[varId].type;
    if (nctype != NC_DOUBLE)
        asThrowException(
                wxString::Format(_("The variable (%s) type (%d) in file doesn't match the desired type (%d)."), varName,
                                 (int) nctype, (int) NC_DOUBLE));

    // Get value
    double val;
    m_status = nc_get_var1_double(m_fileId, varId, &arrIndex, &val);
    if (m_status)
        HandleErrorNetcdf();

    return val;
}

void asFileNetcdf::GetVarArray(const wxString &varName, const size_t indexStart[], const size_t indexCount[],
                               short *pValue)
{
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get the variable value
    int varId = GetVarId(varName);
    if (varId == asNOT_FOUND)
        asThrowException(_("Cannot get the desired variable from the netCDF file."));

    // Check the given type
    nc_type nctype = m_struct.vars[varId].type;
    if (nctype != NC_SHORT)
        asThrowException(
                wxString::Format(_("The variable (%s) type (%d) in file doesn't match the desired type (%d)."), varName,
                                 (int) nctype, (int) NC_SHORT));

    // Get value
    m_status = nc_get_vara_short(m_fileId, varId, indexStart, indexCount, pValue);
    if (m_status) {
        wxString data = wxEmptyString;
        for (size_t i = 0; i < GetVarDimsNb(varId); i++) {
            data.Append(wxString::Format("indexStart[%d]=%d ", i, (int) indexStart[i]));
            data.Append(wxString::Format("indexCount[%d]=%d ", i, (int) indexCount[i]));
        }
        wxString msg = _("Requested indices: ") + data;
        asLogError(msg);
        HandleErrorNetcdf();
    }
}

void asFileNetcdf::GetVarArray(const wxString &varName, const size_t indexStart[], const size_t indexCount[],
                               int *pValue)
{
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get the variable value
    int varId = GetVarId(varName);
    if (varId == asNOT_FOUND)
        asThrowException(_("Cannot get the desired variable from the netCDF file."));

    // Check the given type
    nc_type nctype = m_struct.vars[varId].type;
    if (nctype != NC_INT)
        asThrowException(
                wxString::Format(_("The variable (%s) type (%d) in file doesn't match the desired type (%d)."), varName,
                                 (int) nctype, (int) NC_INT));

    // Get value
    m_status = nc_get_vara_int(m_fileId, varId, indexStart, indexCount, pValue);
    if (m_status) {
        wxString data = wxEmptyString;
        for (size_t i = 0; i < GetVarDimsNb(varId); i++) {
            data.Append(wxString::Format("indexStart[%d]=%d ", i, (int) indexStart[i]));
            data.Append(wxString::Format("indexCount[%d]=%d ", i, (int) indexCount[i]));
        }
        wxString msg = _("Requested indices: ") + data;
        asLogError(msg);
        HandleErrorNetcdf();
    }
}

void asFileNetcdf::GetVarArray(const wxString &varName, const size_t indexStart[], const size_t indexCount[],
                               float *pValue)
{
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get the variable value
    int varId = GetVarId(varName);
    if (varId == asNOT_FOUND)
        asThrowException(_("Cannot get the desired variable from the netCDF file."));

    // Check the given type
    nc_type nctype = m_struct.vars[varId].type;
    if (nctype != NC_FLOAT)
        asThrowException(
                wxString::Format(_("The variable (%s) type (%d) in file doesn't match the desired type (%d)."), varName,
                                 (int) nctype, (int) NC_FLOAT));

    // Get value
    m_status = nc_get_vara_float(m_fileId, varId, indexStart, indexCount, pValue);
    if (m_status) {
        wxString data = wxEmptyString;
        for (size_t i = 0; i < GetVarDimsNb(varId); i++) {
            data.Append(wxString::Format("indexStart[%d]=%d ", i, (int) indexStart[i]));
            data.Append(wxString::Format("indexCount[%d]=%d ", i, (int) indexCount[i]));
        }
        wxString msg = _("Requested indices: ") + data;
        asLogError(msg);
        HandleErrorNetcdf();
    }
}

void asFileNetcdf::GetVarArray(const wxString &varName, const size_t indexStart[], const size_t indexCount[],
                               double *pValue)
{
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get the variable value
    int varId = GetVarId(varName);
    if (varId == asNOT_FOUND)
        asThrowException(_("Cannot get the desired variable from the netCDF file."));

    // Check the given type
    nc_type nctype = m_struct.vars[varId].type;
    if (nctype != NC_DOUBLE)
        asThrowException(
                wxString::Format(_("The variable (%s) type (%d) in file doesn't match the desired type (%d)."), varName,
                                 (int) nctype, (int) NC_DOUBLE));

    // Get value
    m_status = nc_get_vara_double(m_fileId, varId, indexStart, indexCount, pValue);
    if (m_status) {
        wxString data = wxEmptyString;
        for (int i = 0; i < GetVarDimsNb(varId); i++) {
            data.Append(wxString::Format("indexStart[%d]=%d ", i, (int) indexStart[i]));
            data.Append(wxString::Format("indexCount[%d]=%d ", i, (int) indexCount[i]));
        }
        wxString msg = _("Requested indices: ") + data;
        asLogError(msg);
        HandleErrorNetcdf();
    }
}

void asFileNetcdf::GetVarSample(const wxString &varName, const size_t indexStart[], const size_t indexCount[],
                                const ptrdiff_t indexStride[], short *pValue)
{
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get the variable value
    int varId = GetVarId(varName);
    if (varId == asNOT_FOUND)
        asThrowException(_("Cannot get the desired variable from the netCDF file."));

    // Check the given type
    nc_type nctype = m_struct.vars[varId].type;
    if (nctype != NC_SHORT)
        asThrowException(
                wxString::Format(_("The variable (%s) type (%d) in file doesn't match the desired type (%d)."), varName,
                                 (int) nctype, (int) NC_SHORT));

    // Get value
    m_status = nc_get_vars_short(m_fileId, varId, indexStart, indexCount, indexStride, pValue);
    if (m_status) {
        wxString data = wxEmptyString;
        for (int i = 0; i < GetVarDimsNb(varId); i++) {
            data.Append(wxString::Format("indexStart[%d]=%d ", i, (int) indexStart[i]));
            data.Append(wxString::Format("indexCount[%d]=%d ", i, (int) indexCount[i]));
            data.Append(wxString::Format("indexStride[%d]=%d ", i, (int) indexStride[i]));
        }
        wxString msg = _("Requested indices: ") + data;
        asLogError(msg);
        HandleErrorNetcdf();
    }
}

void asFileNetcdf::GetVarSample(const wxString &varName, const size_t indexStart[], const size_t indexCount[],
                                const ptrdiff_t indexStride[], int *pValue)
{
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get the variable value
    int varId = GetVarId(varName);
    if (varId == asNOT_FOUND)
        asThrowException(_("Cannot get the desired variable from the netCDF file."));

    // Check the given type
    nc_type nctype = m_struct.vars[varId].type;
    if (nctype != NC_INT)
        asThrowException(
                wxString::Format(_("The variable (%s) type (%d) in file doesn't match the desired type (%d)."), varName,
                                 (int) nctype, (int) NC_INT));

    // Get value
    m_status = nc_get_vars_int(m_fileId, varId, indexStart, indexCount, indexStride, pValue);
    if (m_status) {
        wxString data = wxEmptyString;
        for (int i = 0; i < GetVarDimsNb(varId); i++) {
            data.Append(wxString::Format("indexStart[%d]=%d ", i, (int) indexStart[i]));
            data.Append(wxString::Format("indexCount[%d]=%d ", i, (int) indexCount[i]));
            data.Append(wxString::Format("indexStride[%d]=%d ", i, (int) indexStride[i]));
        }
        wxString msg = _("Requested indices: ") + data;
        asLogError(msg);
        HandleErrorNetcdf();
    }
}

void asFileNetcdf::GetVarSample(const wxString &varName, const size_t indexStart[], const size_t indexCount[],
                                const ptrdiff_t indexStride[], float *pValue)
{
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get the variable value
    int varId = GetVarId(varName);
    if (varId == asNOT_FOUND)
        asThrowException(_("Cannot get the desired variable from the netCDF file."));

    // Check the given type. Allow the short type here.
    nc_type nctype = m_struct.vars[varId].type;
    if (nctype != NC_FLOAT)
        asThrowException(
                wxString::Format(_("The variable (%s) type (%d) in file doesn't match the desired type (%d)."), varName,
                                 (int) nctype, (int) NC_FLOAT));

    // Get value
    m_status = nc_get_vars_float(m_fileId, varId, indexStart, indexCount, indexStride, pValue);
    if (m_status) {
        wxString data = wxEmptyString;
        for (int i = 0; i < GetVarDimsNb(varId); i++) {
            data.Append(wxString::Format("indexStart[%d]=%d ", i, (int) indexStart[i]));
            data.Append(wxString::Format("indexCount[%d]=%d ", i, (int) indexCount[i]));
            data.Append(wxString::Format("indexStride[%d]=%d ", i, (int) indexStride[i]));
        }
        wxString msg = _("Requested indices: ") + data;
        asLogError(msg);
        HandleErrorNetcdf();
    }
}

void asFileNetcdf::GetVarSample(const wxString &varName, const size_t indexStart[], const size_t indexCount[],
                                const ptrdiff_t indexStride[], double *pValue)
{
    wxASSERT(m_opened);

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Get the variable value
    int varId = GetVarId(varName);
    if (varId == asNOT_FOUND)
        asThrowException(_("Cannot get the desired variable from the netCDF file."));

    // Check the given type
    nc_type nctype = m_struct.vars[varId].type;
    if (nctype != NC_DOUBLE)
        asThrowException(
                wxString::Format(_("The variable (%s) type (%d) in file doesn't match the desired type (%d)."), varName,
                                 (int) nctype, (int) NC_DOUBLE));

    // Get value
    m_status = nc_get_vars_double(m_fileId, varId, indexStart, indexCount, indexStride, pValue);
    if (m_status) {
        wxString data = wxEmptyString;
        for (int i = 0; i < GetVarDimsNb(varId); i++) {
            data.Append(wxString::Format("indexStart[%d]=%d ", i, (int) indexStart[i]));
            data.Append(wxString::Format("indexCount[%d]=%d ", i, (int) indexCount[i]));
            data.Append(wxString::Format("indexStride[%d]=%d ", i, (int) indexStride[i]));
        }
        wxString msg = _("Requested indices: ") + data;
        asLogError(msg);
        HandleErrorNetcdf();
    }
}

void asFileNetcdf::ClearStruct()
{
    for (unsigned int i_var = 0; i_var < m_struct.vars.size(); i_var++) {
        for (unsigned int i_att = 0; i_att < m_struct.vars[i_var].atts.size(); i_att++) {
            if (m_struct.vars[i_var].atts[i_att].pValue != NULL) {
                nc_type nctype = m_struct.vars[i_var].atts[i_att].type;

                // Cleanup from http://stackoverflow.com/questions/206257/freeing-memory-allocated-to-an-array-of-void-pointers
                switch (nctype) {
                    case NC_CHAR: // NC_CHAR - ISO/ASCII character
                    {
                        delete static_cast<char *>( m_struct.vars[i_var].atts[i_att].pValue);
                        break;
                    }

                    case NC_SHORT: // NC_SHORT - signed 2 byte integer
                    {
                        delete static_cast<short *>( m_struct.vars[i_var].atts[i_att].pValue);
                        break;
                    }

                    case NC_INT: // NC_INT - signed 4 byte integer
                    {
                        delete static_cast<int32_t *>( m_struct.vars[i_var].atts[i_att].pValue);
                        break;
                    }

                    case NC_INT64: // NC_INT64 - signed 8 byte integer
                    {
                        delete static_cast<int64_t *>( m_struct.vars[i_var].atts[i_att].pValue);
                        break;
                    }

                    case NC_FLOAT: // NC_FLOAT - single precision floating point number
                    {
                        delete static_cast<float *>( m_struct.vars[i_var].atts[i_att].pValue);
                        break;
                    }

                    case NC_DOUBLE: // NC_DOUBLE - double precision floating point number
                    {
                        delete static_cast<double *>( m_struct.vars[i_var].atts[i_att].pValue);
                        break;
                    }

                    default:
                        asThrowException(wxString::Format(
                                _("NetCDF file: data type (%d) of attribute %s not taken into account in AtmoSwing."),
                                nctype, m_struct.vars[i_var].atts[i_att].name));
                        break;
                }

                m_struct.vars[i_var].atts[i_att].pValue = NULL;
            }
        }
    }

    for (unsigned int i_att = 0; i_att < m_struct.atts.size(); i_att++) {
        if (m_struct.atts[i_att].pValue != NULL) {
            nc_type nctype = m_struct.atts[i_att].type;

            switch (nctype) {
                case NC_CHAR: // NC_CHAR - ISO/ASCII character
                {
                    delete static_cast<char *>( m_struct.atts[i_att].pValue);
                    break;
                }

                case NC_SHORT: // NC_SHORT - signed 2 byte integer
                {
                    delete static_cast<short *>( m_struct.atts[i_att].pValue);
                    break;
                }

                case NC_INT: // NC_INT - signed 4 byte integer
                {
                    delete static_cast<int32_t *>( m_struct.atts[i_att].pValue);
                    break;
                }

                case NC_INT64: // NC_INT64 - signed 8 byte integer
                {
                    delete static_cast<int64_t *>( m_struct.atts[i_att].pValue);
                    break;
                }

                case NC_FLOAT: // NC_FLOAT - single precision floating point number
                {
                    delete static_cast<float *>( m_struct.atts[i_att].pValue);
                    break;
                }

                case NC_DOUBLE: // NC_DOUBLE - double precision floating point number
                {
                    delete static_cast<double *>( m_struct.atts[i_att].pValue);
                    break;
                }

                default:
                    asThrowException(wxString::Format(
                            _("NetCDF file: data type (%d) of attribute %s not taken into account in AtmoSwing."),
                            nctype, m_struct.atts[i_att].name));
                    break;
            }

            m_struct.atts[i_att].pValue = NULL;
        }
    }
}

bool asFileNetcdf::ParseStruct()
{
    // Clear current structure
    ClearStruct();

    // Check that the file is not in define mode
    CheckDefModeClosed();

    // Inquire about the NetCDF Dataset
    int nDims, nVars, nAtts, uDimId;
    m_status = nc_inq(m_fileId, &nDims, &nVars, &nAtts, &uDimId);
    if (m_status)
        HandleErrorNetcdf();

    // Get the file format
    int format;
    m_status = nc_inq_format(m_fileId, &format);
    if (m_status)
        HandleErrorNetcdf();
    switch (format) {
        case (NC_FORMAT_CLASSIC):
            m_struct.format = Classic;
            break;
        case (NC_FORMAT_64BIT):
            m_struct.format = Format64bit;
            break;
        case (NC_FORMAT_NETCDF4):
            m_struct.format = Netcdf4;
            break;
        case (NC_FORMAT_NETCDF4_CLASSIC):
            m_struct.format = Netcdf4Classic;
            break;
        default:
            asLogError(_("The NetCDF format is unknown"));
            return false;
    }

    // Inquire about the dimensions
    for (int dimId = 0; dimId < nDims; dimId++) {
        size_t length;
        char dimNameChar[NC_MAX_NAME + 1];
        m_status = nc_inq_dim(m_fileId, dimId, dimNameChar, &length);
        if (m_status)
            HandleErrorNetcdf();

        NcDimStruct nds = {dimId, wxString(dimNameChar, wxConvUTF8), length};

        m_struct.dims.push_back(nds);
    }

    // FIXME (phorton#1#): Cannot get the Netcdf4 functions ??
    // Find all unlimited dimensions
    int unlimDimIds[NC_MAX_DIMS];
    /*    if(m_status = nc_inq_unlimdims(m_fileId, &m_struct.nUDims, NULL)) HandleErrorNetcdf();
        m_struct.uDimsIds.resize(m_struct.nUDims);
        if(m_status = nc_inq_unlimdims(m_fileId, &m_struct.nUDims, UnlimDimIds)) HandleErrorNetcdf();
        for (int i=0; i<m_struct.nUDims; i++)
        {
            m_struct.uDimsIds[i] = UnlimDimIds[i];
        }*/

    // Find 1 unlimited dimension
    m_struct.uDimIds.resize(1);
    m_status = nc_inq_unlimdim(m_fileId, unlimDimIds);
    if (m_status)
        HandleErrorNetcdf();
    m_struct.uDimIds[0] = unlimDimIds[0];

    // Resize array to store the global attributes
    m_struct.atts.resize(nAtts);

    // Get the global attributes
    for (int attId = 0; attId < nAtts; attId++) {
        // Get the attribute name
        char attNameChar[NC_MAX_NAME + 1];
        m_status = nc_inq_attname(m_fileId, NC_GLOBAL, attId, attNameChar);
        if (m_status)
            HandleErrorNetcdf();
        m_struct.atts[attId].id = attId;
        wxString tmpName(attNameChar, wxConvUTF8);
        m_struct.atts[attId].name = tmpName;

        // Get the attribute type and length
        m_status = nc_inq_att(m_fileId, NC_GLOBAL, attNameChar, &m_struct.atts[attId].type,
                              &m_struct.atts[attId].length);
        if (m_status)
            HandleErrorNetcdf();
        size_t len = m_struct.atts[attId].length;

        // Only store simple attributes
        if (len > 1) {
            m_struct.atts[attId].pValue = NULL;
        } else {
            nc_type nctype = m_struct.atts[attId].type;

            switch (nctype) {
                case NC_CHAR: // NC_CHAR - ISO/ASCII character
                {
                    m_struct.atts[attId].pValue = new char();
                    break;
                }

                case NC_SHORT: // NC_SHORT - signed 2 byte integer
                {
                    m_struct.atts[attId].pValue = new short();
                    break;
                }

                case NC_INT: // NC_INT - signed 4 byte integer
                {
                    m_struct.atts[attId].pValue = new int32_t();
                    break;
                }

                case NC_INT64: // NC_INT64 - signed 8 byte integer
                {
                    m_struct.atts[attId].pValue = new int64_t();
                    break;
                }

                case NC_FLOAT: // NC_FLOAT - single precision floating point number
                {
                    m_struct.atts[attId].pValue = new float();
                    break;
                }

                case NC_DOUBLE: // NC_DOUBLE - double precision floating point number
                {
                    m_struct.atts[attId].pValue = new double();
                    break;
                }

                default:
                    asLogError(wxString::Format(
                            _("NetCDF file: data type (%d) of attribute %s not taken into account in AtmoSwing."),
                            nctype, m_struct.atts[attId].name));
                    return false;
                    break;
            }

            // Get the attribute value
            m_status = nc_get_att(m_fileId, NC_GLOBAL, attNameChar, m_struct.atts[attId].pValue);
            if (m_status)
                HandleErrorNetcdf();

        }
    }

    // Resize arrays to store the variables information
    m_struct.vars.resize(nVars);

    // Get information about the variables and get limited variables (1D)
    for (int varId = 0; varId < nVars; varId++) {
        int nDimsVar, nAttsVar;
        char varNameChar[NC_MAX_NAME + 1];
        int dimIds[NC_MAX_VAR_DIMS];
        m_status = nc_inq_var(m_fileId, varId, varNameChar, &m_struct.vars[varId].type, &nDimsVar, dimIds, &nAttsVar);
        if (m_status)
            HandleErrorNetcdf();
        m_struct.vars[varId].id = varId;
        m_struct.vars[varId].name = wxString(varNameChar, wxConvUTF8);
        m_struct.vars[varId].length = 0;

        m_struct.vars[varId].dimIds.resize(nDimsVar);
        for (int j = 0; j < nDimsVar; j++) {
            m_struct.vars[varId].dimIds[j] = dimIds[j];
        }

        // Find the corresponding dimension to get its length
        for (int dimId = 0; dimId < m_struct.dims.size(); dimId++) {
            if (m_struct.vars[varId].name.IsSameAs(m_struct.dims[dimId].name)) {
                m_struct.vars[varId].length = m_struct.dims[dimId].length;
            }
        }

        // Resize array to store the attributes information
        m_struct.vars[varId].atts.resize(nAttsVar);

        // Get the attributes information
        for (int attId = 0; attId < nAttsVar; attId++) {
            // Get the attribute name
            char attNameChar[NC_MAX_NAME + 1];
            m_status = nc_inq_attname(m_fileId, varId, attId, attNameChar);
            if (m_status)
                HandleErrorNetcdf();
            m_struct.vars[varId].atts[attId].id = attId;
            m_struct.vars[varId].atts[attId].name = wxString(attNameChar, wxConvUTF8);

            // Get the attribute type and length
            m_status = nc_inq_att(m_fileId, varId, attNameChar, &m_struct.vars[varId].atts[attId].type,
                                  &m_struct.vars[varId].atts[attId].length);
            if (m_status)
                HandleErrorNetcdf();
            size_t len = m_struct.vars[varId].atts[attId].length;
            // Only store simple attributes
            if (len > 1) {
                m_struct.vars[varId].atts[attId].pValue = NULL;
            } else {
                nc_type nctype = m_struct.vars[varId].atts[attId].type;

                switch (nctype) {
                    case NC_CHAR: // NC_CHAR - ISO/ASCII character
                    {
                        m_struct.vars[varId].atts[attId].pValue = new char();
                        break;
                    }

                    case NC_SHORT: // NC_SHORT - signed 2 byte integer
                    {
                        m_struct.vars[varId].atts[attId].pValue = new short();
                        break;
                    }

                    case NC_INT: // NC_INT - signed 4 byte integer
                    {
                        m_struct.vars[varId].atts[attId].pValue = new int32_t();
                        break;
                    }

                    case NC_INT64: // NC_INT64 - signed 8 byte integer
                    {
                        m_struct.vars[varId].atts[attId].pValue = new int64_t();
                        break;
                    }

                    case NC_FLOAT: // NC_FLOAT - single precision floating point number
                    {
                        m_struct.vars[varId].atts[attId].pValue = new float();
                        break;
                    }

                    case NC_DOUBLE: // NC_DOUBLE - double precision floating point number
                    {
                        m_struct.vars[varId].atts[attId].pValue = new double();
                        break;
                    }

                    default:
                        asLogError(wxString::Format(
                                _("NetCDF file: data type (%d) of attribute %s not taken into account in AtmoSwing."),
                                nctype, m_struct.vars[varId].atts[attId].name));
                        return false;
                        break;
                }

                // Get the attribute value
                m_status = nc_get_att(m_fileId, varId, attNameChar, m_struct.vars[varId].atts[attId].pValue);
                if (m_status)
                    HandleErrorNetcdf();

            }
        }
    }

    return true;
}

size_t asFileNetcdf::GetVarLength(int &varId) const
{
    wxASSERT(m_opened);

    // No previous checks necessary
    size_t len = 0;

    // Get the variable length
    len = m_struct.vars[varId].length;

    return len;
}
